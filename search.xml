<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[.Net性能测试工具BenchmarkDotnet]]></title>
    <url>%2F2019%2F04%2F06%2F20190406-benchmarkDotnet%2F</url>
    <content type="text"><![CDATA[性能基准测试可以帮助程序员对比2个代码段或者方法的性能，这对于代码重写或者重构来说，可以提供一种很好的量化标准。如果没有性能基准测试，很难想象将方法A改为B方法时候，仅凭肉眼如何区分性能的变化。 BenchmarkDotNetBenchmarkDotNet是一款强力的.Net性能基准测试库，官网 https://benchmarkdotnet.org/。运行时支持 NET Framework (4.6+), .NET Core (2.0+) Mono CoreRT。 BenchmarkDotnet为每个被测试的方法提供了孤立的环境, 使用BenchmarkDotnet, 程序员可以很容易的编写各种性能测试方法，并可以避免许多常见的坑。 代码基准测试(Code Benchmarking)现在我们希望来对比一下Linq to object中First和Single方法的性能 虽然我们知道First的性能肯定比Single高, First方法会在查询到第一个满足条件的对象之后就停止集合遍历，而Single找到第一个满足条件的对象之后，不会停止查找，它会去继续查找集合中的剩余对象，直到遍历整个集合或者在集合中找到第二个匹配条件的对象。 这里我们只是为了演示一下如何进行代码基准测试。 为了使用BenchmarkDotNet来进行代码基准测试，我们首先创建一个空的.Net Core控制台程序。 然后我们使用Package Manage Console添加BenchmarkDotNet库 PM&gt; Install-Package BenchmarkDotNet 然后我们修改Program.cs文件, 代码如下 123456789101112131415161718192021222324252627282930public class Program&#123; public class SingleVsFirst &#123; private readonly List&lt;string&gt; _haystack = new List&lt;string&gt;(); private readonly int _haystackSize = 1000000; private readonly string _needle = &quot;needle&quot;; public SingleVsFirst() &#123; //Add a large amount of items to our list. Enumerable.Range(1, _haystackSize).ToList().ForEach(x =&gt; _haystack.Add(x.ToString())); //Insert the needle right in the middle. _haystack.Insert(_haystackSize / 2, _needle); &#125; [Benchmark] public string Single() =&gt; _haystack.SingleOrDefault(x =&gt; x == _needle); [Benchmark] public string First() =&gt; _haystack.FirstOrDefault(x =&gt; x == _needle); &#125; public static void Main(string[] args) &#123; var summary = BenchmarkRunner.Run&lt;SingleVsFirst&gt;(); Console.ReadLine(); &#125;&#125; 代码解释说明 以上代码中SingleVsFtirs类是一个测试类。 测试类中我们生成了一个拥有100万对象的字符串集合。 我们在集合的中间位置插入了一个测试字符串，字符串的内容是”needle”。 代码中的Single和First方法，分别调用了Linq to - object的SingleOrDefault和FirstOrDefault方法- 来查询字符串集合中的”needle”字符串。 在Single和First方法上，我们加入[Benchmark]特性, 拥有该特性的方法会出现在最后的基准检测报告中。 注意： 测试的方法必须是公开的(public), 如果把public去掉，程序不会产生任何结果 在运行程序之前，还有一步关键的操作，测试的程序需要使用Release模式编译，并且不能附加任何调试器(Debugger) 最终结果现在我们运行程序，程序产生的最终报告如下 Method Mean Error StdDev Median Single 28.12 ms 0.9347 ms 2.697 ms 28.93 ms First 13.30 ms 0.8394 ms 2.475 ms 14.48 ms 带测试参数的基准测试(Input Benchmarking)BenchmarkDotNet中我们还可以使用[ParamsSource]参数来指定测试的用例范围。在上面的代码中，我们测试了匹配字符串在集合中间位置时，First和Single的效率对比，下面我们修改上面的代码，我们希望分别测试匹配字符串在集合头部，尾部以及中间位置时First和Single的效率对比。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;using System.Collections.Generic;using System.Linq; using BenchmarkDotNet.Attributes;using BenchmarkDotNet.Running; namespace BenchmarkExample&#123; public class SingleVsFirst &#123; private readonly List&lt;string&gt; _haystack = new List&lt;string&gt;(); private readonly int _haystackSize = 1000000; public List&lt;string&gt; _needles =&gt; new List&lt;string&gt; &#123; &quot;StartNeedle&quot;, &quot;MiddleNeedle&quot;, &quot;EndNeedle&quot; &#125;; public SingleVsFirst() &#123; //Add a large amount of items to our list. Enumerable.Range(1, _haystackSize).ToList().ForEach(x =&gt; _haystack.Add(x.ToString())); //One at the start. _haystack.Insert(0, _needles[0]); //One right in the middle. _haystack.Insert(_haystackSize / 2, _needles[1]); //One at the end. _haystack.Insert(_haystack.Count - 1, _needles[2]); &#125; [ParamsSource(nameof(_needles))] public string Needle &#123; get; set; &#125; [Benchmark] public string Single() =&gt; _haystack.SingleOrDefault(x =&gt; x == Needle); [Benchmark] public string First() =&gt; _haystack.FirstOrDefault(x =&gt; x == Needle); &#125; class Program &#123; static void Main(string[] args) &#123; var summary = BenchmarkRunner.Run&lt;SingleVsFirst&gt;(); Console.ReadLine(); &#125; &#125;&#125; 代码解释说明 我们创建了测试的用例字符串集合_needles 在构造函数中，我们在字符串集合的头部，中部，尾部分别插入了3个字符串 我们添加了一个属性Needle, 表示当前测试的用例，在被测试Single和First方法中，我们使用属性Needle来匹配 在属性Needle上我们加上了参数来源特性[ParamsSource], 并设置参数来源是_needles 最终效果现在我们运行程序，程序产生的最终报告如下 Method Needle Mean Error StdDev Median Single EndNeedle 23,266,757.53 ns 432,206.593 ns 591,609.263 ns 23,236,343.07 ns First EndNeedle 24,984,621.12 ns 494,223.345 ns 783,890.599 ns 24,936,945.21 ns Single MiddleNeedle 21,379,814.14 ns 806,253.579 ns 2,377,256.870 ns 22,436,101.14 ns First MiddleNeedle 11,984,519.09 ns 315,184.021 ns 924,380.173 ns 12,233,700.94 ns Single StartNeedle 23,650,243.23 ns 599,968.173 ns 714,219.431 ns 23,555,402.19 ns First StartNeedle 89.17 ns 1.864 ns 2.732 ns 89.07 ns 从结果上看 当匹配字符串在集合头部的时候，First性能比Single高的多 当匹配字符串在集合中部的时候，First性能是比Single的一倍 当匹配字符串在集合尾部的时候，First和比Single的性能差不多 加入内存测试在.NET Core中的CSV解析库中，我们使用了以下代码 1234567891011121314151617181920212223[MemoryDiagnoser] public class CsvBenchmarking &#123; [Benchmark(Baseline =true)] public IEnumerable&lt;Automobile&gt; CSVHelper() &#123; TextReader reader = new StreamReader(&quot;import.txt&quot;); var csvReader = new CsvReader(reader); var records = csvReader.GetRecords&lt;Automobile&gt;(); return records.ToList(); &#125; [Benchmark] public IEnumerable&lt;Automobile&gt; TinyCsvParser() &#123; CsvParserOptions csvParserOptions = new CsvParserOptions(true, &apos;,&apos;); var csvParser = new CsvParser&lt;Automobile&gt;(csvParserOptions, new CsvAutomobileMapping()); var records = csvParser.ReadFromFile(&quot;import.txt&quot;, Encoding.UTF8); return records.Select(x =&gt; x.Result).ToList(); &#125; &#125; 其中除了[Benchmark]特性，我们还在测试类CsvBenchmarking上添加了[MemoryDiagnoser]特性，该特性会在测试报告中追加，2个方法执行时的内存使用情况。 Method Mean Scaled Allocated CSVHelper 1,404.5 ms 1.00 244.39 MB TinyCsvParser 381.6 ms 0.27 32.53 MB 其中Allocated表明了内存占用情况。 总结 BenchmarkDotNet绝对是.NET开发人员了解代码性能，以及对比代码性能的必备神器。]]></content>
  </entry>
  <entry>
    <title><![CDATA[《微信小程序运营实战》的阅读感想]]></title>
    <url>%2F2019%2F04%2F02%2F20190402-read-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%90%A5%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[page 136 例如，张小龙介绍小程序时提到的汽车站购票场景中，用户扫描小程序二维码的概率远高于线上。这其实相当于购票小程序分享了汽车客运站所独占的用户时间，从而使用户更愿意关注和使用此种场景下的小程序。 抢占用户线下的时间片段，同时满足将商业致于无形的理念。]]></content>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将已有项目绑定到git上]]></title>
    <url>%2F2019%2F04%2F01%2F2019040101-git-create-repository%2F</url>
    <content type="text"><![CDATA[1. 创建远程仓库 登录github，在上边创建一个仓库 复制仓库链接，比如为git@github.com:alex-my/some-project.git 2.初始化本地仓库进入本地项目执行以下命令123456// 初始化本地仓库git init// 添加全部文件git add .// 提交到本地仓库git commit -m “提交说明” 3.本地仓库与远程仓库绑定绑定到远程仓库，并提交1234// 绑定，并取一个别名，通常用origin，后面的地址是前边创建的远程仓库地址git remote add origin git@github.com:alex-my/some-project.git// 把本地仓库地址提交到远程仓库git push origin master 4.修改本地仓库，并提交到远程仓库假设修改了README.md文件在根目录或者在文件所在目录执行12345678910git add .// 查看变动git status// 提交到本地仓库git commit -m “modify reade.md”// 如果是多人合作的项目,请先pullgit pull// 推送到远程仓库(第一个使用默认,作用和第一个一样)git pushgit push origin master 5.仓库别名如果有多个仓库或者多个分支，在推送或者拉取的时候需要注意12git pull 仓库别名 仓库分支git push 仓库别名 仓库分支 遇到问题,如下图解决方法：git push -f origin master]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
