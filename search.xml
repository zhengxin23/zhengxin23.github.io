<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java10的新特性]]></title>
    <url>%2F2019%2F05%2F24%2F20190524-Java-Java10%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Java 10的新特性1. 局部变量类型推断局部变量类型推断可以说是Java 10中最值得注意的特性，这是Java语言开发人员为了简化Java应用程序的编写而采取的又一步，如下图所示。这个新功能将为Java增加一些语法糖 - 简化它并改善开发者体验。新的语法将减少与编写Java相关的冗长度，同时保持对静态类型安全性的承诺。局部变量类型推断将引入”var”关键字，也就是你可以随意定义变量而不必指定变量的类型，如：将被下面这个新语法所取代：看完是不是有点JS的即视感？？？越来越像JS了吗？！虽然类型推断在Java中不是一个新概念，但在局部变量中确是很大的一个改进。说到类型推断，从JDK 5引进泛型，到JDK 7的”&lt;&gt;”操作符允许不绑定类型而初始化List，再到JDK 8的Lambda表达式，再到现在JDK 10的局部变量类型推断，Java类型推断正大刀阔斧的向前发展。局部变量类型推荐仅限于如下使用场景： 局部变量初始化 for循环内部索引变量 传统的for循环声明变量 Java官方表示，它不能用于以下几个地方： 方法参数 构造函数参数 方法返回类型 字段 捕获表达式（或任何其他类型的变量声明）2. GC改进和内存管理JDK 10中有2个JEP专门用于改进当前的垃圾收集元素。第一个垃圾收集器接口是（JEP 304），它将引入一个纯净的垃圾收集器接口，以帮助改进不同垃圾收集器的源代码隔离。预定用于Java 10的第二个JEP是针对G1的并行完全GC（JEP 307），其重点在于通过完全GC并行来改善G1最坏情况的等待时间。G1是Java 9中的默认GC，并且此JEP的目标是使G1平行。3. 线程本地握手（JEP 312）JDK 10将引入一种在线程上执行回调的新方法，因此这将会很方便能停止单个线程而不是停止全部线程或者一个都不停。4. 备用内存设备上的堆分配（JEP 316）允许HotSpot VM在备用内存设备上分配Java对象堆内存，该内存设备将由用户指定。5. 其他Unicode语言 - 标记扩展（JEP 314）目标是增强java.util.Locale及其相关的API，以便实现语言标记语法的其他Unicode扩展（BCP 47）。6. 基于Java的实验性JIT编译器Oracle希望将其Java JIT编译器Graal用作Linux / x64平台上的实验性JIT编译器。7. 根证书（JEP 319）这个的目标是在Oracle的Java SE中开源根证书。8. 根证书颁发认证这将使OpenJDK对开发人员更具吸引力，它还旨在减少OpenJDK和Oracle JDK构建之间的差异。9. 将JDK生态整合单个存储库（JEP 296）此JEP的主要目标是执行一些内存管理，并将JDK生态的众多存储库组合到一个存储库中。10. 删除工具javah（JEP 313）从JDK中移除了javah工具，这个很简单并且很重要。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序-云开发云调用API没有权限(no permission)问题]]></title>
    <url>%2F2019%2F05%2F06%2F20190506-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BA%91%E5%BC%80%E5%8F%91%E4%BA%91%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天在学习微信小程序云开发中的在云函数中使用云调用api templateMessage.send 时，在开发环境中运行报错：function has no permission to call this API如下图： 查找总结原因大概有两点： 云函数所在目录缺少个权限声明文件config.json 12345&#123; &quot;permissions&quot;: &#123; &quot;openapi&quot;: [&quot;templateMessage.send&quot;] &#125;&#125; 将微信开发工具升级到 v1.02.1904090 版本以上后，重新上传部署云函数 解决如上两个问题后，运行正确 另外在这过程中遇到另外一个问题，在云函数中调用 templateMessage.send 时，云函数如下：123456789101112131415161718192021222324252627282930313233343536// 云函数入口文件const cloud = require(&apos;wx-server-sdk&apos;)cloud.init()exports.main = async (event, context) =&gt; &#123; try &#123; let formId = event.formId; const result = await cloud.openapi.templateMessage.send(&#123; touser: cloud.getWXContext().OPENID, // 通过 getWXContext 获取 OPENID page: &apos;index&apos;, data: &#123; keyword1: &#123; value: &apos;氢能总部&apos; &#125;, keyword2: &#123; value: &apos;小明&apos; &#125;, keyword3: &#123; value: &apos;18:00&apos; &#125;, keyword4: &#123; value: &apos;云浮思劳&apos; &#125; &#125;, templateId: &apos;MYlxdani6r7yU0ldtZqadxxxxxxxxxxxxx&apos;, formId: formId, emphasisKeyword: &apos;keyword1.DATA&apos; &#125;) // result 结构 // &#123; errCode: 0, errMsg: &apos;openapi.templateMessage.send:ok&apos; &#125; return result &#125; catch (err) &#123; // 错误处理 // err.errCode !== 0 throw err &#125;&#125; 在开发工具中报错：openapi.templateMessage.send:fail invalid form id hint如下图： 经查找原因为：在开发工具中支行时， e.detail.formId 的值为 the formId is a mock one这个值需要在真机调试中才会正常出现，点击真机调试，并在手机上再次点击这个功能按钮，果然打印了正常的 formId。使用开发工具中的”真机调试”运行成功。]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WPF ListBoxItem DataTemplate Command无效问题]]></title>
    <url>%2F2019%2F04%2F30%2F20190430-wpf-listboxitem-datatemplate-command%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天使用wpf的prism开发项目时，需要有在ListBox中的ListBoxItem触发命令的需求，在创建ListBoxItem的DataTemplate时，将prism的viewmodel中定义的command绑定到DataTemplate的Command上，如下：12345&lt;DataTemplate x:Key=&quot;CanIdTemplate&quot; DataType=&quot;&#123;x:Type sys:String&#125;&quot;&gt; &lt;materialDesign:Chip Content=&quot;&#123;Binding&#125;&quot; Margin=&quot;5,5,0,0&quot; IsDeletable=&quot;True&quot; DeleteCommand=&quot;&#123;Binding CanIdChipDeleteCommand&#125;&quot;&gt; &lt;/materialDesign:Chip&gt;&lt;/DataTemplate&gt; 但在运行时发现 CanIdChipDeleteCommand 没有触发。然后将 materialDesign:Chip 单独放到其他控件容器里运行时可以正确触发命令。经试验分析，应该是因为 DataTemplate 与 数据模板运行时加载所在的控件 的上下文是独立的，而默认绑定情况下在prism的ViewModel中定义的CanIdChipDeleteCommand命令在 DataTemplate 中的上下文找不到。可以通过修改绑定方式，将命令绑定的目标关联到与 ViewModel 所在的同一个上下文中。修改代码如下：1234567891011121314151617181920&lt;UserControl x:Class=&quot;VrmsServer.Desktop.Views.Functions.Configure.TboxCanIdSettingControl&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:prism=&quot;http://prismlibrary.com/&quot; xmlns:materialDesign=&quot;http://materialdesigninxaml.net/winfx/xaml/themes&quot; xmlns:i=&quot;http://schemas.microsoft.com/expression/2010/interactivity&quot; xmlns:converter=&quot;clr-namespace:VrmsServer.Desktop.Converter&quot; xmlns:sys=&quot;clr-namespace:System;assembly=mscorlib&quot; Background=&quot;#d7d7d7&quot; x:Name=&quot;userControl&quot; prism:ViewModelLocator.AutoWireViewModel=&quot;True&quot;&gt; &lt;UserControl.Resources&gt; &lt;DataTemplate x:Key=&quot;CanIdTemplate&quot; DataType=&quot;&#123;x:Type sys:String&#125;&quot;&gt; &lt;materialDesign:Chip Content=&quot;&#123;Binding&#125;&quot; Margin=&quot;5,5,0,0&quot; IsDeletable=&quot;True&quot; DeleteCommand=&quot;&#123;Binding ElementName=userControl, Path=DataContext.CanIdChipDeleteCommand&#125;&quot; DeleteCommandParameter=&quot;&#123;Binding&#125;&quot;&gt; &lt;/materialDesign:Chip&gt; &lt;/DataTemplate&gt; &lt;/UserControl.Resources&gt;&lt;/UserControl&gt; 代码修改如上后，可以正确触发 ViewModel 中的 CanIdChipDeleteCommand 命令了。]]></content>
      <tags>
        <tag>prism</tag>
        <tag>wpf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一条路]]></title>
    <url>%2F2019%2F04%2F26%2F20190425-thoughtsOfOneRoad%2F</url>
    <content type="text"><![CDATA[对一条路的认识从陌生到熟悉后，有时候会有一种怀念当初陌生的感觉。因为那时在这条路上，才刚开始，一切都值得憧憬。因为那时在这条路上，感觉生涩，一切都值得好奇。]]></content>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dbKoda连接mongodb出现ConnectNamedPipe Failed错误]]></title>
    <url>%2F2019%2F04%2F16%2F20190416-dbKoda%E8%BF%9E%E6%8E%A5mongodb%E5%87%BA%E9%94%99%2F</url>
    <content type="text"><![CDATA[最近使用 dbKoda 连接 mongodb 数据库出现错误 1. dbKoda连接mongodb出现ConnectNamedPipe Failed错误出错提示如下：Error lauching WinPTY agent : ConnectNamedPipe failed:Window error 232 at new WindowsPtyAgent(……) 2. 关闭 McAfee 实时保护功能后连接成功经各种方法尝试后，发现关闭 McAfee 实时保护功能后，连接成功]]></content>
      <tags>
        <tag>mongodb</tag>
        <tag>dbKoda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《微信小程序运营实战》的阅读感想]]></title>
    <url>%2F2019%2F04%2F08%2F20190402-read-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%90%A5%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[page 136 例如，张小龙介绍小程序时提到的汽车站购票场景中，用户扫描小程序二维码的概率远高于线上。这其实相当于购票小程序分享了汽车客运站所独占的用户时间，从而使用户更愿意关注和使用此种场景下的小程序。 抢占用户线下的时间片段，同时满足将商业致于无形的理念。 page 167 很多人一辈子都未必会去电影院看一场电影或者去演唱会现场听音乐，这也并非是因为他们的购买力较低，而是因为他们更喜欢在乘坐公交车、排队付款等碎片化的场景中随时随地地获取这些内容。例如，部分人喜欢在洗澡的时候听音乐，部分人喜欢在乘坐公交车时看动漫，还有人喜欢边吃饭边看视频……将自己感兴趣的内容与生活场景进行搭配并组合后，可以让他们的生活变得更加丰富多彩。 当代人生活中碎片化的时间越来越普遍，小程序的轻快特性正好适合嵌入到这些碎片时间里。]]></content>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次创建.NetCore控制台程序编译失败问题]]></title>
    <url>%2F2019%2F04%2F07%2F20190407-dotnetcore-app-first%2F</url>
    <content type="text"><![CDATA[随着微软对.NetCore的不断推进发展，作为.Net阵营的开发人员，开始着手跟上脚步学习.NetCore 创建 .NetCore 控制台程序第一次创建控制台程序，编译时出现了如下问题,依赖项出现黄色叹号警告，很多程序库未引用。有点让人摸不着头脑，想首次来个”hello, world”就给抛出难题 其中一项错误为： 找不到资产文件”…\project.assets.json”。运行NuGet包还原以生成此文件。 猜想应该与 NuGet 程序包管理问题相关。 dotnet 命令创建控制台程序dotnet命令创建控制台项目三步曲： dotnet new console - o netcore2 dotnet restore netcore2\netcore2.csproj dotnet run -p netcore2\netcore2.csproj 使用命令创建的项目能正常编译运行 查看命令行与vs创建项目的过程，有区别的可能为第二步：dotnet restore - 恢复项目的依赖项和工具。 用该命令应用于用vs创建的控制台项目后，可以正常编译及执行了。但按道理不可能每次使用vs创建项目都需要使用命令行执行dotnet restore一下吧，这也太麻烦了。 NuGet 包管理器设置几经周折，找到原来vs上有设置程序包还原的选项，可以依据项目自动恢复依赖项和工具。将如上图的两个选项勾选-确定。 终于编译并执行成功NuGet包管理器设置好后，“重新生成”控制台项目，终于可以编译和执行成功了。 总结 不知道VS为什么不自动勾选后这两个选项，让开发人员省点心…… Hello .NetCore 解锁完成]]></content>
      <tags>
        <tag>.NetCore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.Net性能测试工具BenchmarkDotnet]]></title>
    <url>%2F2019%2F04%2F06%2F20190406-benchmarkDotnet%2F</url>
    <content type="text"><![CDATA[性能基准测试可以帮助程序员对比2个代码段或者方法的性能，这对于代码重写或者重构来说，可以提供一种很好的量化标准。如果没有性能基准测试，很难想象将方法A改为B方法时候，仅凭肉眼如何区分性能的变化。 BenchmarkDotNetBenchmarkDotNet是一款强力的.Net性能基准测试库，官网 https://benchmarkdotnet.org/。运行时支持 NET Framework (4.6+), .NET Core (2.0+) Mono CoreRT。 BenchmarkDotnet为每个被测试的方法提供了孤立的环境, 使用BenchmarkDotnet, 程序员可以很容易的编写各种性能测试方法，并可以避免许多常见的坑。 代码基准测试(Code Benchmarking)现在我们希望来对比一下Linq to object中First和Single方法的性能 虽然我们知道First的性能肯定比Single高, First方法会在查询到第一个满足条件的对象之后就停止集合遍历，而Single找到第一个满足条件的对象之后，不会停止查找，它会去继续查找集合中的剩余对象，直到遍历整个集合或者在集合中找到第二个匹配条件的对象。 这里我们只是为了演示一下如何进行代码基准测试。 为了使用BenchmarkDotNet来进行代码基准测试，我们首先创建一个空的.Net Core控制台程序。 然后我们使用Package Manage Console添加BenchmarkDotNet库 PM&gt; Install-Package BenchmarkDotNet 然后我们修改Program.cs文件, 代码如下 123456789101112131415161718192021222324252627282930public class Program&#123; public class SingleVsFirst &#123; private readonly List&lt;string&gt; _haystack = new List&lt;string&gt;(); private readonly int _haystackSize = 1000000; private readonly string _needle = &quot;needle&quot;; public SingleVsFirst() &#123; //Add a large amount of items to our list. Enumerable.Range(1, _haystackSize).ToList().ForEach(x =&gt; _haystack.Add(x.ToString())); //Insert the needle right in the middle. _haystack.Insert(_haystackSize / 2, _needle); &#125; [Benchmark] public string Single() =&gt; _haystack.SingleOrDefault(x =&gt; x == _needle); [Benchmark] public string First() =&gt; _haystack.FirstOrDefault(x =&gt; x == _needle); &#125; public static void Main(string[] args) &#123; var summary = BenchmarkRunner.Run&lt;SingleVsFirst&gt;(); Console.ReadLine(); &#125;&#125; 代码解释说明 以上代码中SingleVsFtirs类是一个测试类。 测试类中我们生成了一个拥有100万对象的字符串集合。 我们在集合的中间位置插入了一个测试字符串，字符串的内容是”needle”。 代码中的Single和First方法，分别调用了Linq to - object的SingleOrDefault和FirstOrDefault方法- 来查询字符串集合中的”needle”字符串。 在Single和First方法上，我们加入[Benchmark]特性, 拥有该特性的方法会出现在最后的基准检测报告中。 注意： 测试的方法必须是公开的(public), 如果把public去掉，程序不会产生任何结果 在运行程序之前，还有一步关键的操作，测试的程序需要使用Release模式编译，并且不能附加任何调试器(Debugger) 最终结果现在我们运行程序，程序产生的最终报告如下 Method Mean Error StdDev Median Single 28.12 ms 0.9347 ms 2.697 ms 28.93 ms First 13.30 ms 0.8394 ms 2.475 ms 14.48 ms 带测试参数的基准测试(Input Benchmarking)BenchmarkDotNet中我们还可以使用[ParamsSource]参数来指定测试的用例范围。在上面的代码中，我们测试了匹配字符串在集合中间位置时，First和Single的效率对比，下面我们修改上面的代码，我们希望分别测试匹配字符串在集合头部，尾部以及中间位置时First和Single的效率对比。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;using System.Collections.Generic;using System.Linq; using BenchmarkDotNet.Attributes;using BenchmarkDotNet.Running; namespace BenchmarkExample&#123; public class SingleVsFirst &#123; private readonly List&lt;string&gt; _haystack = new List&lt;string&gt;(); private readonly int _haystackSize = 1000000; public List&lt;string&gt; _needles =&gt; new List&lt;string&gt; &#123; &quot;StartNeedle&quot;, &quot;MiddleNeedle&quot;, &quot;EndNeedle&quot; &#125;; public SingleVsFirst() &#123; //Add a large amount of items to our list. Enumerable.Range(1, _haystackSize).ToList().ForEach(x =&gt; _haystack.Add(x.ToString())); //One at the start. _haystack.Insert(0, _needles[0]); //One right in the middle. _haystack.Insert(_haystackSize / 2, _needles[1]); //One at the end. _haystack.Insert(_haystack.Count - 1, _needles[2]); &#125; [ParamsSource(nameof(_needles))] public string Needle &#123; get; set; &#125; [Benchmark] public string Single() =&gt; _haystack.SingleOrDefault(x =&gt; x == Needle); [Benchmark] public string First() =&gt; _haystack.FirstOrDefault(x =&gt; x == Needle); &#125; class Program &#123; static void Main(string[] args) &#123; var summary = BenchmarkRunner.Run&lt;SingleVsFirst&gt;(); Console.ReadLine(); &#125; &#125;&#125; 代码解释说明 我们创建了测试的用例字符串集合_needles 在构造函数中，我们在字符串集合的头部，中部，尾部分别插入了3个字符串 我们添加了一个属性Needle, 表示当前测试的用例，在被测试Single和First方法中，我们使用属性Needle来匹配 在属性Needle上我们加上了参数来源特性[ParamsSource], 并设置参数来源是_needles 最终效果现在我们运行程序，程序产生的最终报告如下 Method Needle Mean Error StdDev Median Single EndNeedle 23,266,757.53 ns 432,206.593 ns 591,609.263 ns 23,236,343.07 ns First EndNeedle 24,984,621.12 ns 494,223.345 ns 783,890.599 ns 24,936,945.21 ns Single MiddleNeedle 21,379,814.14 ns 806,253.579 ns 2,377,256.870 ns 22,436,101.14 ns First MiddleNeedle 11,984,519.09 ns 315,184.021 ns 924,380.173 ns 12,233,700.94 ns Single StartNeedle 23,650,243.23 ns 599,968.173 ns 714,219.431 ns 23,555,402.19 ns First StartNeedle 89.17 ns 1.864 ns 2.732 ns 89.07 ns 从结果上看 当匹配字符串在集合头部的时候，First性能比Single高的多 当匹配字符串在集合中部的时候，First性能是比Single的一倍 当匹配字符串在集合尾部的时候，First和比Single的性能差不多 加入内存测试在.NET Core中的CSV解析库中，我们使用了以下代码 1234567891011121314151617181920212223[MemoryDiagnoser] public class CsvBenchmarking &#123; [Benchmark(Baseline =true)] public IEnumerable&lt;Automobile&gt; CSVHelper() &#123; TextReader reader = new StreamReader(&quot;import.txt&quot;); var csvReader = new CsvReader(reader); var records = csvReader.GetRecords&lt;Automobile&gt;(); return records.ToList(); &#125; [Benchmark] public IEnumerable&lt;Automobile&gt; TinyCsvParser() &#123; CsvParserOptions csvParserOptions = new CsvParserOptions(true, &apos;,&apos;); var csvParser = new CsvParser&lt;Automobile&gt;(csvParserOptions, new CsvAutomobileMapping()); var records = csvParser.ReadFromFile(&quot;import.txt&quot;, Encoding.UTF8); return records.Select(x =&gt; x.Result).ToList(); &#125; &#125; 其中除了[Benchmark]特性，我们还在测试类CsvBenchmarking上添加了[MemoryDiagnoser]特性，该特性会在测试报告中追加，2个方法执行时的内存使用情况。 Method Mean Scaled Allocated CSVHelper 1,404.5 ms 1.00 244.39 MB TinyCsvParser 381.6 ms 0.27 32.53 MB 其中Allocated表明了内存占用情况。 总结 BenchmarkDotNet绝对是.NET开发人员了解代码性能，以及对比代码性能的必备神器。]]></content>
      <tags>
        <tag>.Net</tag>
        <tag>性能</tag>
        <tag>BenchmarkDotnet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ant-design-pro脚手架第一次使用及问题]]></title>
    <url>%2F2019%2F04%2F05%2F20190405-ant-design-pro%E8%84%9A%E6%89%8B%E6%9E%B6%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E5%8F%8A%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近计划开发一个中后台平台，学习研究了一段时间 react技术栈，感觉其以组件为核心思想的开发思路，有助于构建可复用的、相对易于维护的系统。由于UI设计方面比较薄弱，想依靠大平台的UI框架。查看了圈，感觉阿里的Ant Design挺符合心水。依靠大平台的设计理念，避免个人用户体验设计理念不足，避免个人开发出来的系统体验东一个想法西一个想法，导致系统体验太不专业。研究了一个ant-design-pro 感觉不错。开始着手搭建ant-design-pro demo工程，熟悉下。依据官网看似简单的步骤，但在过程中遇到一些莫名的问题，搞了两三天终于运行成功了…… 参照官网步骤 github：https://github.com/ant-design/ant-design-pro demo搭建步骤如下： 1234git clone https://github.com/ant-design/ant-design-pro.git --depth=1cd ant-design-pronpm installnpm start # visit http://localhost:8000 在 npm install 步骤时，一直出现各种依赖包安装失败等等等等等等各种摸不着头脑的问题 如：某个依赖包无法安装、json解析出错等。 如：npm ERR! Error: EPERM: operation not permitted, 使用管理员权限也解决不了 忘记截图保存了，自己脑补下吧~~ 如失败提示网上搜索，基本都没有很准确的解决方法。 最后通过将 npm 降到版本4后，终于安装部署成功了，汗。 原先安装时，为版本8；中间试过降到版本6也不行。 npm降版本命令： npm i npm@4 -g 总结这种前端框架，有点不好就是依赖项目太多，每个依赖项目的版本已很多。在版本不匹配时，出现一些莫名其妙的问题，如果很方便的路径进行解决！]]></content>
      <tags>
        <tag>react</tag>
        <tag>ant-design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将已有项目绑定到git上]]></title>
    <url>%2F2019%2F04%2F01%2F2019040101-git-create-repository%2F</url>
    <content type="text"><![CDATA[1. 创建远程仓库 登录github，在上边创建一个仓库 复制仓库链接，比如为git@github.com:alex-my/some-project.git 2.初始化本地仓库进入本地项目执行以下命令123456// 初始化本地仓库git init// 添加全部文件git add .// 提交到本地仓库git commit -m “提交说明” 3.本地仓库与远程仓库绑定绑定到远程仓库，并提交1234// 绑定，并取一个别名，通常用origin，后面的地址是前边创建的远程仓库地址git remote add origin git@github.com:alex-my/some-project.git// 把本地仓库地址提交到远程仓库git push origin master 4.修改本地仓库，并提交到远程仓库假设修改了README.md文件在根目录或者在文件所在目录执行12345678910git add .// 查看变动git status// 提交到本地仓库git commit -m “modify reade.md”// 如果是多人合作的项目,请先pullgit pull// 推送到远程仓库(第一个使用默认,作用和第一个一样)git pushgit push origin master 5.仓库别名如果有多个仓库或者多个分支，在推送或者拉取的时候需要注意12git pull 仓库别名 仓库分支git push 仓库别名 仓库分支 遇到问题,如下图解决方法：git push -f origin master]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数参数前面单星号（*）和双星号（**）的区别]]></title>
    <url>%2F2019%2F03%2F05%2F20190305-python-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%89%8D%E9%9D%A2%E5%8D%95%E6%98%9F%E5%8F%B7%E5%92%8C%E5%8F%8C%E6%98%9F%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在python的函数中经常能看到输入的参数前面有一个或者两个星号：例如12def foo(param1, *param2):def bar(param1, **param2): 这两种用法其实都是用来将任意个数的参数导入到python函数中。 单星号（）：agrs将所以参数以元组(tuple)的形式导入：例如：1234def foo(param1, *param2): print param1 print param2foo(1,2,3,4,5) 1(2, 3, 4, 5)双星号（）：kwargs将参数以字典的形式导入1234def bar(param1, **param2): print param1 print param2bar(1,a=2,b=3) 1{‘a’: 2, ‘b’: 3}此外，单星号的另一个用法是解压参数列表：1234def foo(bar, lee): print bar, leel = [1, 2]foo(*l) 1 2当然这两个用法可以同时出现在一个函数中：例如123456def foo(a, b=10, *args, **kwargs): print a print b print args print kwargsfoo(1, 2, 3, 4, e=5, f=6, g=7) 123 4{‘e’: 5, ‘g’: 7, ‘f’: 6}]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序设置box-shadow阴影在真机上无效]]></title>
    <url>%2F2019%2F01%2F06%2F20190106-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AEbox-shadow%E9%98%B4%E5%BD%B1%E5%9C%A8%E7%9C%9F%E6%9C%BA%E4%B8%8A%E6%97%A0%E6%95%88%2F</url>
    <content type="text"><![CDATA[微信小程序设置box-shadow阴影无效，如下： box-shadow: 0rpx 10rpx 50rpx 10rpx #5555551A; 在开发环境上有效，但在真机上无效。解决办法：使用rgba创建颜色后，在IDE和真机上都有效了。 box-shadow: 0rpx 10rpx 50rpx 10rpx rgba(85, 85, 85, 0.10);]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序post请求服务器端 No HTTP resource was found 问题]]></title>
    <url>%2F2018%2F11%2F30%2F20181130-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Fpost%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AFNo-HTTP-resource-was-found%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[小程序端代码：12345678910111213141516wx.request(&#123; url: getApp().globalData.webApiUrlRoot + &apos;/api/User/test&apos;, method: &apos;POST&apos;, header: &#123; &apos;content-type&apos;: &apos;application/json&apos; // 默认值 &#125;, data:&#123; a:&quot;1&quot; &#125;, success(res) &#123; console.log(res); &#125;, complete(res) &#123; console.log(res); &#125; &#125;); ASP.NET web api :12345[HttpPost]public string test(string a)&#123; return &quot;hello&quot;;&#125; 请求结果失败，应答内容：“No HTTP resource was found that matches the request URI ‘http://localhost:57437/api/User/test&#39;.&quot; 原因为：POST方法只能接收 Content-Type 为 application/x-www-form-urlencoded 和 multipart/form-data 的 POST 数据]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
</search>
