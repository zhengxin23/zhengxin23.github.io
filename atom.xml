<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郑廿三</title>
  
  <subtitle>爱程序 | 爱读书 | 爱运动 | 爱生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhengxin23.github.io/"/>
  <updated>2019-06-10T13:08:32.927Z</updated>
  <id>https://zhengxin23.github.io/</id>
  
  <author>
    <name>zheng xin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019全球logo设计趋势</title>
    <link href="https://zhengxin23.github.io/2019/06/10/20190610-2019logotrend/"/>
    <id>https://zhengxin23.github.io/2019/06/10/20190610-2019logotrend/</id>
    <published>2019-06-10T12:44:31.000Z</published>
    <updated>2019-06-10T13:08:32.927Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-摩尔斯阴影-Morse-Shade"><a href="#1-摩尔斯阴影-Morse-Shade" class="headerlink" title="1. 摩尔斯阴影 (Morse Shade)"></a>1. 摩尔斯阴影 (Morse Shade)</h3><p>一串同心的点和破折号。用一个愉快的新方法来打破传统阴影的视觉张力，同时提供一个纯矢量解决方案。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SuU1P75Sp3AnAz8mm9nkjRu5wwLQYVDjZwlFdnkM1rgUJTPmSibAfRXrHaeDDEFSibXTgXXLYJ1TcWuNJIu4DeicQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt><br><a id="more"></a></p><h3 id="2-复合叠加-Loaded"><a href="#2-复合叠加-Loaded" class="headerlink" title="2. 复合叠加 (Loaded)"></a>2. 复合叠加 (Loaded)</h3><p>建立一个具有清晰信息的顶级高对比度图层，并将其加载到一个从属图形上。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SuU1P75Sp3AnAz8mm9nkjRu5wwLQYVDjoibBfBFQia37uE9gCEGibbrS3CibXEHQUrTI5lwY6GGEwnwjX87GiamZs9Q/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p><h3 id="3-单一阴影-Orphan-Shadows"><a href="#3-单一阴影-Orphan-Shadows" class="headerlink" title="3. 单一阴影 (Orphan Shadows)"></a>3. 单一阴影 (Orphan Shadows)</h3><p>可以展示自己的抱负或其他尚未确定的资产。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SuU1P75Sp3AnAz8mm9nkjRu5wwLQYVDj1o6iaMI6kEDVrOnb9Unj0clS5d6rdymfeg0F455F9RuLwfWyVhxjISQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p><h3 id="4-拉链色调-Zip-Tone"><a href="#4-拉链色调-Zip-Tone" class="headerlink" title="4. 拉链色调 (Zip Tone)"></a>4. 拉链色调 (Zip Tone)</h3><p>复古、有点粗糙但回归机器时代。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SuU1P75Sp3AnAz8mm9nkjRu5wwLQYVDjjsty1tR40ZkFJOL909ExJOc5hNafiaogjzPpTBwO1ITVjbcbZmfXQSQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p><h3 id="5-点-Dots"><a href="#5-点-Dots" class="headerlink" title="5. 点 (Dots)"></a>5. 点 (Dots)</h3><p>打破紧张的平面色调区域，使作品富有张力，并有一定趣味性。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SuU1P75Sp3AnAz8mm9nkjRu5wwLQYVDjvt57xEc5RMMsvzbtlSXbu1icZ87yLt1ZqYD8aSakDUicyzw3Ex854WPw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p><h3 id="6-高光强调-Highlights"><a href="#6-高光强调-Highlights" class="headerlink" title="6. 高光强调 (Highlights)"></a>6. 高光强调 (Highlights)</h3><p>高光点睛、色彩火花让这些标志摆脱潜在的平庸。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SuU1P75Sp3AnAz8mm9nkjRu5wwLQYVDjcQ1ghKb6Uv2gqialgNgpYYKf7IVC9EKIhNZkCR6ibyf7oplU3ZvfGcHw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p><h3 id="7-等分-Quarters"><a href="#7-等分-Quarters" class="headerlink" title="7. 等分 (Quarters)"></a>7. 等分 (Quarters)</h3><p>传递出更简单、更清晰的信号。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SuU1P75Sp3AnAz8mm9nkjRu5wwLQYVDjQn5lYbS4aMcoFgLia5M7szqUHaOETUoy4T5rhZ4DIYJzecyVTwbYqbA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p><h3 id="8-拼接符号-Spell-Signs"><a href="#8-拼接符号-Spell-Signs" class="headerlink" title="8. 拼接符号 (Spell Signs)"></a>8. 拼接符号 (Spell Signs)</h3><p>和谐一致，并且很可能充满了强大的意义。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SuU1P75Sp3AnAz8mm9nkjRu5wwLQYVDjmrT3GD4ETHzibgVibpUcJJyKsD6DFQurp4Npzqsmb3TiaZdott4n3sEQw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p><h3 id="9-孔洞-Holes"><a href="#9-孔洞-Holes" class="headerlink" title="9. 孔洞 (Holes)"></a>9. 孔洞 (Holes)</h3><p>隐藏的负空间，为了向消费者说明只有它们才能解决的不完整性，也让公众参与到这个品牌难题中。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SuU1P75Sp3AnAz8mm9nkjRu5wwLQYVDjzMlCQuRmIyqkH8uGmDKllCFayeA39k9C17wkQNO0tUMOsibhO099Lbw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p><h3 id="10-圆点拖动-Spot-Drag"><a href="#10-圆点拖动-Spot-Drag" class="headerlink" title="10. 圆点拖动 (Spot Drag)"></a>10. 圆点拖动 (Spot Drag)</h3><p>充满活力、生动、新鲜、充满潜力。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SuU1P75Sp3AnAz8mm9nkjRu5wwLQYVDjaW9DMopjUBhHiaIiau9PJeFHsXeOwuL60pictngaMVaJibh2KO6wpZhQKw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p><h3 id="11-渐变-Gradient-Breaks"><a href="#11-渐变-Gradient-Breaks" class="headerlink" title="11. 渐变 (Gradient Breaks)"></a>11. 渐变 (Gradient Breaks)</h3><p>演示运动和变换。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SuU1P75Sp3AnAz8mm9nkjRu5wwLQYVDjhFKKp10zzptL93w0icDOrElIXqm73384eNucswZeaZegIvqhOHibhiaVQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p><h3 id="12-轮廓条纹-Contour-Strips"><a href="#12-轮廓条纹-Contour-Strips" class="headerlink" title="12. 轮廓条纹 (Contour Strips)"></a>12. 轮廓条纹 (Contour Strips)</h3><p>表现一些维度的变化，展示技术的准确性，测量的方法、能力和一致性。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SuU1P75Sp3AnAz8mm9nkjRu5wwLQYVDjflVqWZjb6bY6W6rrRujkydJyyjzYp1OrDNupCSXke6r28iazyzIvQGA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p><h3 id="13-句点-Period"><a href="#13-句点-Period" class="headerlink" title="13. 句点 (Period)"></a>13. 句点 (Period)</h3><p>提升了设计对话的智慧和趣味。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SuU1P75Sp3AnAz8mm9nkjRu5wwLQYVDjUOIQwpH4YmSL7fKB2S00VgmFdtibAtYEgID10kntYYnbrO0GMOLO1Ew/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p><h3 id="14-翅膀-Wings"><a href="#14-翅膀-Wings" class="headerlink" title="14. 翅膀 (Wings)"></a>14. 翅膀 (Wings)</h3><p>流畅美感、灵动<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SuU1P75Sp3AnAz8mm9nkjRu5wwLQYVDjwPoatib0yAPgsxpfqSk5hLABUqpu2xQjcbow29qEuokDKcEriaSKGEIA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p><h3 id="15-门-Doors"><a href="#15-门-Doors" class="headerlink" title="15. 门 (Doors)"></a>15. 门 (Doors)</h3><p>窥视到另一个维度，邀请我们成为一个窥探者或参与者。象征能行的权利、通往解决方案的途径、机会或欢迎的标志。<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/SuU1P75Sp3AnAz8mm9nkjRu5wwLQYVDj31oCFnJb50IQOKS31wPWPppPzdVmjawa7696FIY0BqPMh0BmPANuVQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></p><blockquote><p>每一项设计都代表着来自世界各地的设计师们数小时的思考和斗争，我们一如既往地尊重和敬佩他们对徽标设计的奉献，并感谢他们在帮助我们创建这些报告中发挥的重要作用。<br>原文链接： <a href="https://mp.weixin.qq.com/s/a_N-Q9Q0S9rX_xTF5mX3yQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/a_N-Q9Q0S9rX_xTF5mX3yQ</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-摩尔斯阴影-Morse-Shade&quot;&gt;&lt;a href=&quot;#1-摩尔斯阴影-Morse-Shade&quot; class=&quot;headerlink&quot; title=&quot;1. 摩尔斯阴影 (Morse Shade)&quot;&gt;&lt;/a&gt;1. 摩尔斯阴影 (Morse Shade)&lt;/h3&gt;&lt;p&gt;一串同心的点和破折号。用一个愉快的新方法来打破传统阴影的视觉张力，同时提供一个纯矢量解决方案。&lt;br&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/SuU1P75Sp3AnAz8mm9nkjRu5wwLQYVDjZwlFdnkM1rgUJTPmSibAfRXrHaeDDEFSibXTgXXLYJ1TcWuNJIu4DeicQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Design" scheme="https://zhengxin23.github.io/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>fetch跨域请求问题之带参数请求</title>
    <link href="https://zhengxin23.github.io/2019/05/31/20190531-javascript-fetch%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98%E4%B9%8B%E5%B8%A6%E5%8F%82%E6%95%B0%E8%AF%B7%E6%B1%82/"/>
    <id>https://zhengxin23.github.io/2019/05/31/20190531-javascript-fetch跨域请求问题之带参数请求/</id>
    <published>2019-05-31T05:49:22.000Z</published>
    <updated>2019-05-31T07:58:02.706Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前写一篇 fetch 跨域请求解决方法的问题，当时使用的是 get 请求<br>当时使用了第二次解决方法,在Reponse的Headers上添加控制设置项</p></blockquote><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>在使用 fetch 进行 post 跨域请求时，出现新的问题<br>post请求代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;http://localhost:57437/api/ReactDashboard/GetVehicleInfoArray&apos;,</span><br><span class="line">&#123;</span><br><span class="line">method: &apos;POST&apos;,</span><br><span class="line">    headers:&#123;</span><br><span class="line">        &apos;Content-Type&apos;:&apos;application/json; charset=utf-8&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    body: &#123;</span><br><span class="line">        factoryCodeList</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(res =&gt; &#123; </span><br><span class="line">    console.log(res);</span><br><span class="line">    return res.json();</span><br><span class="line">&#125;).then(json =&gt; &#123;</span><br><span class="line">    console.log(&apos;获取的结果&apos;, json);</span><br><span class="line">    return json;</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(&apos;请求错误&apos;, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>执行结果报错如下：<br><img src="https://i.loli.net/2019/05/31/5cf0c273e8a1214394.png" alt><br><a id="more"></a></p><h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>分析报错结果发现很奇怪，明明是POST请求，为什么报OPTIONS操作出错<br><code>OPTIONS http://localhost:57437/api/ReactDashboard/GetVehicleInfoArray net::ERR_ABORTED 405 (Method Not Allowed)</code></p><p>首先，搞清楚 HTTP 405 的定义:<br><strong>HTTP 405</strong></p><blockquote><p>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 　　鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</p></blockquote><p>其次，分析为什么请求变成了 OPTIONS 操作，经查找资料分析：<br>不仅仅是fetch，只要你满足以下几种情况，都会去发起一个 Preflighted requests，也就是options请求，参见链接：<br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests" target="_blank" rel="noopener">HTTP access control (CORS)</a></p><blockquote><ul><li>It uses methods other than GET, HEAD or POST.  Also, if POST is used to send request data with a Content-Type other than application/x-www-form-urlencoded, multipart/form-data, ortext/plain, e.g. if the POST request sends an XML payload to the server using application/xmlor text/xml application/json, then the request is preflighted.</li><li>It sets custom headers in the request (e.g. the request uses a header such as X-PINGOTHER)</li></ul></blockquote><p>触发这几个条件中的其中一种了吧，浏览器在发起跨域请求的时候会带着一个<code>Origin</code> header，那么其实就是个custom headers，那么也就会先触发一个Preflighted requests，<br><a href="https://fetch.spec.whatwg.org/#http-requests" target="_blank" rel="noopener">Fetch Standard</a> 也有提到。</p><h3 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3. 解决方法"></a>3. 解决方法</h3><p>（1）在web应用服务器上（如IIS）中的 <code>HTTP响应头</code>设置中添加相应CORS的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials : true</span><br><span class="line">Access-Control-Allow-Headers : *</span><br><span class="line">Access-Control-Allow-Methods : PUT,POST,GET,DELETE,OPTIONS</span><br><span class="line">Access-Control-Allow-Origin : http://localhost:8000</span><br></pre></td></tr></table></figure></p><p>（2）在web应用启动时，添加CORS配置，如果的 C# web api 可以使用Nuget搜索<code>microsoft.aspnet.webapi.cors</code>组件进行CORS相关配置。可参考博文<a href="https://www.cnblogs.com/landeanfen/p/5177176.html" target="_blank" rel="noopener">C#进阶系列——WebApi 跨域问题解决方案：CORS</a><br>前端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;http://localhost:57437/api/ReactDashboard/GetVehicleInfoArray&apos;,</span><br><span class="line">&#123;</span><br><span class="line">method: &apos;POST&apos;,</span><br><span class="line">    headers:&#123;</span><br><span class="line">        &apos;Content-Type&apos;:&apos;application/json&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    body: factoryCodeList</span><br><span class="line">&#125;).then(res =&gt; &#123; </span><br><span class="line">    console.log(res);</span><br><span class="line">    return res.json();</span><br><span class="line">&#125;).then(json =&gt; &#123;</span><br><span class="line">    console.log(&apos;获取的结果&apos;, json);</span><br><span class="line">    return json;</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(&apos;请求错误&apos;, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>后端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[HttpPost]</span><br><span class="line">public List&lt;VehicleInfo&gt; GetVehicleInfoArray(string[] factoryCodeList)</span><br><span class="line">&#123;</span><br><span class="line">    //TODO ACTIONS</span><br><span class="line">    return vehicleInfoList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（3）使用原始的content-type <code>application/x-www-form-urlencoded</code> 进行带参数 <code>POST</code> 操作，避免发起Preflighted requests，也就是options请求<br>前端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;http://localhost:57437/api/ReactDashboard/GetVehicleInfoArray&apos;,</span><br><span class="line">&#123;</span><br><span class="line">method: &apos;POST&apos;,</span><br><span class="line">    headers:&#123;</span><br><span class="line">        &apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    body: &#123;</span><br><span class="line">        factoryCodeList</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(res =&gt; &#123; </span><br><span class="line">    console.log(res);</span><br><span class="line">    return res.json();</span><br><span class="line">&#125;).then(json =&gt; &#123;</span><br><span class="line">    console.log(&apos;获取的结果&apos;, json);</span><br><span class="line">    return json;</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(&apos;请求错误&apos;, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>后端代码（C# web api）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> [HttpPost]</span><br><span class="line">public HttpResponseMessage GetVehicleInfoArray([FromBody]JObject param)</span><br><span class="line">&#123;</span><br><span class="line">    dynamic obj = param;</span><br><span class="line">    string[] factoryCodeList = ((JArray)obj.indexArray).ToObject&lt;string[]&gt;();</span><br><span class="line">    //TODO ACTIONS</span><br><span class="line">    return httpResponseMessage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前写一篇 fetch 跨域请求解决方法的问题，当时使用的是 get 请求&lt;br&gt;当时使用了第二次解决方法,在Reponse的Headers上添加控制设置项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-问题描述&quot;&gt;&lt;a href=&quot;#1-问题描述&quot; class=&quot;headerlink&quot; title=&quot;1. 问题描述&quot;&gt;&lt;/a&gt;1. 问题描述&lt;/h3&gt;&lt;p&gt;在使用 fetch 进行 post 跨域请求时，出现新的问题&lt;br&gt;post请求代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fetch(&amp;apos;http://localhost:57437/api/ReactDashboard/GetVehicleInfoArray&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	method: &amp;apos;POST&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    headers:&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;apos;Content-Type&amp;apos;:&amp;apos;application/json; charset=utf-8&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    body: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        factoryCodeList&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(res =&amp;gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(res);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return res.json();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(json =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(&amp;apos;获取的结果&amp;apos;, json);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return json;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).catch(err =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(&amp;apos;请求错误&amp;apos;, err);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;执行结果报错如下：&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/05/31/5cf0c273e8a1214394.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://zhengxin23.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="https://zhengxin23.github.io/tags/es6/"/>
    
      <category term="fetch" scheme="https://zhengxin23.github.io/tags/fetch/"/>
    
  </entry>
  
  <entry>
    <title>fetch跨域请求问题</title>
    <link href="https://zhengxin23.github.io/2019/05/28/20190528-javascript-fetch%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/"/>
    <id>https://zhengxin23.github.io/2019/05/28/20190528-javascript-fetch跨域请求问题/</id>
    <published>2019-05-28T02:48:13.000Z</published>
    <updated>2019-05-31T05:51:35.390Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在调试 ant-design-pro 项目时里面使用 fetch 方法进行 api 请求</p></blockquote><p>想通过保持与 ant-design-pro 一致的api请求方式进行获取自己系统中的数据，<br>请求代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;http://www.demo.com:9001/api/Tbox/GetAllVehicleFactoryWithUploadDateTimeDesc&apos;).then(res =&gt; &#123; </span><br><span class="line">    console.log(res);</span><br><span class="line">    return res.json();</span><br><span class="line">&#125;).then(json =&gt; &#123;</span><br><span class="line">    console.log(&apos;获取的结果&apos;, json);</span><br><span class="line">    return json;</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(&apos;请求错误&apos;, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>执行结果：<br>Access to fetch at ‘<a href="http://www.demo.com:9001/api/Tbox/GetAllVehicleFactoryWithUploadDateTimeDesc&#39;" target="_blank" rel="noopener">http://www.demo.com:9001/api/Tbox/GetAllVehicleFactoryWithUploadDateTimeDesc&#39;</a> from origin ‘<a href="http://localhost:8000&#39;" target="_blank" rel="noopener">http://localhost:8000&#39;</a> has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. If an opaque response serves your needs, set the request’s mode to ‘no-cors’ to fetch the resource with CORS disabled.<br>VM20690:8 请求错误 TypeError: Failed to fetch</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>经查资料分析，浏览器只允许请求当前域的资源，而对其他域的资源表示不信任。</p></blockquote><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>cors是”Cross-Origin Resource Sharing”的简称，是实现跨域的一种方式，相对于其他跨域方式，比较灵活，而且不限制发请求使用的method，以下从几种情况分析cors使用。<br>那怎么才算跨域呢？</p><ul><li>请求协议http,https的不同</li><li>域domain的不同</li><li>端口port的不同</li></ul><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>1. 前端代码</strong><br>添加请求参数， mode : ‘cors’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;http://www.demo.com:9001/api/Tbox/GetAllVehicleFactoryWithUploadDateTimeDesc&apos;,&#123;</span><br><span class="line">    method: &apos;GET&apos;,</span><br><span class="line">    mode: &apos;cors&apos;</span><br><span class="line">&#125;).then(res =&gt; &#123; </span><br><span class="line">    console.log(res);</span><br><span class="line">    return res.json();</span><br><span class="line">&#125;).then(json =&gt; &#123;</span><br><span class="line">    console.log(&apos;获取的结果&apos;, json);</span><br><span class="line">    return json;</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(&apos;请求错误&apos;, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>2. 后端设置</strong><br>(1)以IIS为示例<br>设置HTTP响应标头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials : true</span><br><span class="line">Access-Control-Allow-Headers : *</span><br><span class="line">Access-Control-Allow-Methods : PUT,POST,GET,DELETE,OPTIONS</span><br><span class="line">Access-Control-Allow-Origin : http://localhost:8000</span><br></pre></td></tr></table></figure></p><p>说明：</p><ol><li><a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a> 为你所在运行环境执行请求的地址</li><li>对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为“*”。这是因为请求的首部中携带了 Cookie 信息，如果 Access-Control-Allow-Origin 的值为“*”，请求将会失败。而将 Access-Control-Allow-Origin 的值设置为 <a href="http://localhost:8000，则请求将成功执行。" target="_blank" rel="noopener">http://localhost:8000，则请求将成功执行。</a></li></ol><p>(2)在Response的Headers中设置HTTP响应标头<br>如下以 C# Web Api 为示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpResponseMessage result = request.CreateResponse&lt;T&gt;(HttpStatusCode.OK, content);</span><br><span class="line">result.Headers.Add(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">result.Headers.Add(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br><span class="line">result.Headers.Add(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);</span><br><span class="line">result.Headers.Add(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8000&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="其他参数说明"><a href="#其他参数说明" class="headerlink" title="其他参数说明"></a>其他参数说明</h3><ul><li><p><strong>request跨域头部介绍</strong></p><ul><li>Access-Control-Allow-Origin：可以允许哪些客户端来访问，指可以是*，也可以是某个域名或者用逗号隔开的域名列表。</li><li>Access-Control-Expose-Headers： 浏览器可以访问的一些头部。</li><li>Access-Control-Max-Age：预检查结果可以缓存的问题</li><li>Access-Control-Allow-Methods：指定客户端发请求可以使用的方法</li><li>Access-Control-Allow-Headers：指定客户端发请求可以使用的头部。</li><li>Access-Control-Allow-Credentials: 指定客户端是否可以携带cookie等认证信息(前端fetch设置withCredentials：true进行发送cookie),如果是简单请求等跨域得确保此response头设置为true。</li></ul></li></ul><ul><li><p><strong>response头部</strong></p><ul><li>Access-Control-Allow-Origin：可以允许哪些客户端来访问，指可以是*，也可以是某个域名或者用逗号隔开的域名列表。</li><li>Access-Control-Expose-Headers： 浏览器可以访问的一些头部。</li><li>Access-Control-Max-Age：预检查结果可以缓存的问题</li><li>Access-Control-Allow-Methods：指定客户端发请求可以使用的方法</li><li>Access-Control-Allow-Headers：指定客户端发请求可以使用的头部。</li><li>Access-Control-Allow-Credentials: 指定客户端是否可以携带cookie等认证信息(前端fetch设置withCredentials：true进行发送cookie),如果是简单请求等跨域得确保此response头设置为true。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在调试 ant-design-pro 项目时里面使用 fetch 方法进行 api 请求&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想通过保持与 ant-design-pro 一致的api请求方式进行获取自己系统中的数据，&lt;br&gt;请求代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fetch(&amp;apos;http://www.demo.com:9001/api/Tbox/GetAllVehicleFactoryWithUploadDateTimeDesc&amp;apos;).then(res =&amp;gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(res);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return res.json();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(json =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(&amp;apos;获取的结果&amp;apos;, json);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return json;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).catch(err =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(&amp;apos;请求错误&amp;apos;, err);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://zhengxin23.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="https://zhengxin23.github.io/tags/es6/"/>
    
      <category term="fetch" scheme="https://zhengxin23.github.io/tags/fetch/"/>
    
  </entry>
  
  <entry>
    <title>Java10的新特性</title>
    <link href="https://zhengxin23.github.io/2019/05/24/20190524-Java-Java10%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://zhengxin23.github.io/2019/05/24/20190524-Java-Java10的新特性/</id>
    <published>2019-05-24T14:45:17.000Z</published>
    <updated>2019-05-25T06:34:21.948Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-局部变量类型推断"><a href="#1-局部变量类型推断" class="headerlink" title="1. 局部变量类型推断"></a>1. 局部变量类型推断</h4><p>局部变量类型推断可以说是Java 10中最值得注意的特性，这是Java语言开发人员为了简化Java应用程序的编写而采取的又一步，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20190524224043136.png" alt="在这里插入图片描述"><br>这个新功能将为Java增加一些语法糖 - 简化它并改善开发者体验。新的语法将减少与编写Java相关的冗长度，同时保持对静态类型安全性的承诺。<br>局部变量类型推断将引入”var”关键字，也就是你可以随意定义变量而不必指定变量的类型，如：<br>将被下面这个新语法所取代：<br>看完是不是有点JS的即视感？？？越来越像JS了吗？！虽然类型推断在Java中不是一个新概念，但在局部变量中确是很大的一个改进。<br>说到类型推断，从JDK 5引进泛型，到JDK 7的”&lt;&gt;”操作符允许不绑定类型而初始化List，再到JDK 8的Lambda表达式，再到现在JDK 10的局部变量类型推断，Java类型推断正大刀阔斧的向前发展。<br><a id="more"></a><br>局部变量类型推荐仅限于如下使用场景：</p><ul><li>局部变量初始化</li><li>for循环内部索引变量</li><li>传统的for循环声明变量</li></ul><p>Java官方表示，它不能用于以下几个地方：</p><ul><li>方法参数</li><li>构造函数参数</li><li>方法返回类型</li><li>字段</li><li>捕获表达式（或任何其他类型的变量声明）</li></ul><h4 id="2-GC改进和内存管理"><a href="#2-GC改进和内存管理" class="headerlink" title="2. GC改进和内存管理"></a>2. GC改进和内存管理</h4><p>JDK 10中有2个JEP专门用于改进当前的垃圾收集元素。<br>第一个垃圾收集器接口是（JEP 304），它将引入一个纯净的垃圾收集器接口，以帮助改进不同垃圾收集器的源代码隔离。<br>预定用于Java 10的第二个JEP是针对G1的并行完全GC（JEP 307），其重点在于通过完全GC并行来改善G1最坏情况的等待时间。G1是Java 9中的默认GC，并且此JEP的目标是使G1平行。</p><h4 id="3-线程本地握手（JEP-312）"><a href="#3-线程本地握手（JEP-312）" class="headerlink" title="3. 线程本地握手（JEP 312）"></a>3. 线程本地握手（JEP 312）</h4><p>JDK 10将引入一种在线程上执行回调的新方法，因此这将会很方便能停止单个线程而不是停止全部线程或者一个都不停。</p><h4 id="4-备用内存设备上的堆分配（JEP-316）"><a href="#4-备用内存设备上的堆分配（JEP-316）" class="headerlink" title="4. 备用内存设备上的堆分配（JEP 316）"></a>4. 备用内存设备上的堆分配（JEP 316）</h4><p>允许HotSpot VM在备用内存设备上分配Java对象堆内存，该内存设备将由用户指定。</p><h4 id="5-其他Unicode语言-标记扩展（JEP-314）"><a href="#5-其他Unicode语言-标记扩展（JEP-314）" class="headerlink" title="5. 其他Unicode语言 - 标记扩展（JEP 314）"></a>5. 其他Unicode语言 - 标记扩展（JEP 314）</h4><p>目标是增强java.util.Locale及其相关的API，以便实现语言标记语法的其他Unicode扩展（BCP 47）。</p><h4 id="6-基于Java的实验性JIT编译器"><a href="#6-基于Java的实验性JIT编译器" class="headerlink" title="6. 基于Java的实验性JIT编译器"></a>6. 基于Java的实验性JIT编译器</h4><p>Oracle希望将其Java JIT编译器Graal用作Linux / x64平台上的实验性JIT编译器。</p><h4 id="7-根证书（JEP-319）"><a href="#7-根证书（JEP-319）" class="headerlink" title="7. 根证书（JEP 319）"></a>7. 根证书（JEP 319）</h4><p>这个的目标是在Oracle的Java SE中开源根证书。</p><h4 id="8-根证书颁发认证"><a href="#8-根证书颁发认证" class="headerlink" title="8. 根证书颁发认证"></a>8. 根证书颁发认证</h4><p>这将使OpenJDK对开发人员更具吸引力，它还旨在减少OpenJDK和Oracle JDK构建之间的差异。</p><h4 id="9-将JDK生态整合单个存储库（JEP-296）"><a href="#9-将JDK生态整合单个存储库（JEP-296）" class="headerlink" title="9. 将JDK生态整合单个存储库（JEP 296）"></a>9. 将JDK生态整合单个存储库（JEP 296）</h4><p>此JEP的主要目标是执行一些内存管理，并将JDK生态的众多存储库组合到一个存储库中。</p><h4 id="10-删除工具javah（JEP-313）"><a href="#10-删除工具javah（JEP-313）" class="headerlink" title="10. 删除工具javah（JEP 313）"></a>10. 删除工具javah（JEP 313）</h4><p>从JDK中移除了javah工具，这个很简单并且很重要。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-局部变量类型推断&quot;&gt;&lt;a href=&quot;#1-局部变量类型推断&quot; class=&quot;headerlink&quot; title=&quot;1. 局部变量类型推断&quot;&gt;&lt;/a&gt;1. 局部变量类型推断&lt;/h4&gt;&lt;p&gt;局部变量类型推断可以说是Java 10中最值得注意的特性，这是Java语言开发人员为了简化Java应用程序的编写而采取的又一步，如下图所示。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190524224043136.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;这个新功能将为Java增加一些语法糖 - 简化它并改善开发者体验。新的语法将减少与编写Java相关的冗长度，同时保持对静态类型安全性的承诺。&lt;br&gt;局部变量类型推断将引入”var”关键字，也就是你可以随意定义变量而不必指定变量的类型，如：&lt;br&gt;将被下面这个新语法所取代：&lt;br&gt;看完是不是有点JS的即视感？？？越来越像JS了吗？！虽然类型推断在Java中不是一个新概念，但在局部变量中确是很大的一个改进。&lt;br&gt;说到类型推断，从JDK 5引进泛型，到JDK 7的”&amp;lt;&amp;gt;”操作符允许不绑定类型而初始化List，再到JDK 8的Lambda表达式，再到现在JDK 10的局部变量类型推断，Java类型推断正大刀阔斧的向前发展。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://zhengxin23.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序-云开发云调用API没有权限(no permission)问题</title>
    <link href="https://zhengxin23.github.io/2019/05/06/20190506-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BA%91%E5%BC%80%E5%8F%91%E4%BA%91%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <id>https://zhengxin23.github.io/2019/05/06/20190506-微信小程序-云开发云调用失败问题/</id>
    <published>2019-05-06T12:26:06.000Z</published>
    <updated>2019-05-06T12:44:10.811Z</updated>
    
    <content type="html"><![CDATA[<p>今天在学习微信小程序云开发中的在云函数中使用云调用api <code>templateMessage.send</code> 时，在开发环境中运行报错：function has no permission to call this API<br>如下图：<br><img src="https://i.loli.net/2019/05/06/5cd028aa7ff76.png" alt></p><a id="more"></a><p>查找总结原因大概有两点：</p><ol><li><p>云函数所在目录缺少个权限声明文件<br>config.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;permissions&quot;: &#123;</span><br><span class="line">    &quot;openapi&quot;: [&quot;templateMessage.send&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将微信开发工具升级到 v1.02.1904090 版本以上后，重新上传部署云函数</p></li></ol><p>解决如上两个问题后，运行正确<br><img src="https://i.loli.net/2019/05/06/5cd028aa3c647.png" alt></p><h2 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h2><p>在这过程中遇到另外一个问题，在云函数中调用 <code>templateMessage.send</code> 时，<br>云函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 云函数入口文件</span><br><span class="line">const cloud = require(&apos;wx-server-sdk&apos;)</span><br><span class="line">cloud.init()</span><br><span class="line">exports.main = async (event, context) =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    let formId = event.formId;</span><br><span class="line">    const result = await cloud.openapi.templateMessage.send(&#123;</span><br><span class="line">      touser: cloud.getWXContext().OPENID, // 通过 getWXContext 获取 OPENID</span><br><span class="line">      page: &apos;index&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        keyword1: &#123;</span><br><span class="line">          value: &apos;氢能总部&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        keyword2: &#123;</span><br><span class="line">          value: &apos;小明&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        keyword3: &#123;</span><br><span class="line">          value: &apos;18:00&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        keyword4: &#123;</span><br><span class="line">          value: &apos;云浮思劳&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      templateId: &apos;MYlxdani6r7yU0ldtZqadxxxxxxxxxxxxx&apos;,</span><br><span class="line">      formId: formId,</span><br><span class="line">      emphasisKeyword: &apos;keyword1.DATA&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    // result 结构</span><br><span class="line">    // &#123; errCode: 0, errMsg: &apos;openapi.templateMessage.send:ok&apos; &#125;</span><br><span class="line">    return result</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    // 错误处理</span><br><span class="line">    // err.errCode !== 0</span><br><span class="line">    throw err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在开发工具中报错：openapi.templateMessage.send:fail invalid form id hint<br>如下图：<br><img src="https://i.loli.net/2019/05/06/5cd028aa702ac.png" alt></p><p>经查找原因为：<br>在开发工具中支行时， <code>e.detail.formId</code> 的值为 <code>the formId is a mock one</code><br>这个值需要在真机调试中才会正常出现，点击真机调试，并在手机上再次点击这个功能按钮，果然打印了正常的 formId。使用开发工具中的”真机调试”运行成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在学习微信小程序云开发中的在云函数中使用云调用api &lt;code&gt;templateMessage.send&lt;/code&gt; 时，在开发环境中运行报错：function has no permission to call this API&lt;br&gt;如下图：&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/05/06/5cd028aa7ff76.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="微信小程序" scheme="https://zhengxin23.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>WPF ListBoxItem DataTemplate Command无效问题</title>
    <link href="https://zhengxin23.github.io/2019/04/30/20190430-wpf-listboxitem-datatemplate-command%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <id>https://zhengxin23.github.io/2019/04/30/20190430-wpf-listboxitem-datatemplate-command无效问题/</id>
    <published>2019-04-30T07:21:25.000Z</published>
    <updated>2019-04-30T07:50:14.162Z</updated>
    
    <content type="html"><![CDATA[<p>今天使用wpf的prism开发项目时，需要有在ListBox中的ListBoxItem触发命令的需求，<br>在创建ListBoxItem的DataTemplate时，将prism的viewmodel中定义的command绑定到DataTemplate的Command上，<br>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;DataTemplate x:Key=&quot;CanIdTemplate&quot; DataType=&quot;&#123;x:Type sys:String&#125;&quot;&gt;</span><br><span class="line">    &lt;materialDesign:Chip Content=&quot;&#123;Binding&#125;&quot; Margin=&quot;5,5,0,0&quot; IsDeletable=&quot;True&quot;</span><br><span class="line">                         DeleteCommand=&quot;&#123;Binding CanIdChipDeleteCommand&#125;&quot;&gt;</span><br><span class="line">    &lt;/materialDesign:Chip&gt;</span><br><span class="line">&lt;/DataTemplate&gt;</span><br></pre></td></tr></table></figure></p><p>但在运行时发现 <code>CanIdChipDeleteCommand</code> 没有触发。<br><a id="more"></a><br>然后将 <code>materialDesign:Chip</code> 单独放到其他控件容器里运行时可以正确触发命令。<br>经试验分析，应该是因为 DataTemplate 与 数据模板运行时加载所在的控件 的上下文是独立的，<br>而默认绑定情况下在prism的ViewModel中定义的<code>CanIdChipDeleteCommand</code>命令在 DataTemplate 中的上下文找不到。<br>可以通过修改绑定方式，将命令绑定的目标关联到与 ViewModel 所在的同一个上下文中。<br>修改代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserControl x:Class=&quot;VrmsServer.Desktop.Views.Functions.Configure.TboxCanIdSettingControl&quot;</span><br><span class="line">             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">             xmlns:prism=&quot;http://prismlibrary.com/&quot;</span><br><span class="line">             xmlns:materialDesign=&quot;http://materialdesigninxaml.net/winfx/xaml/themes&quot;</span><br><span class="line">             xmlns:i=&quot;http://schemas.microsoft.com/expression/2010/interactivity&quot;</span><br><span class="line">             xmlns:converter=&quot;clr-namespace:VrmsServer.Desktop.Converter&quot;</span><br><span class="line">             xmlns:sys=&quot;clr-namespace:System;assembly=mscorlib&quot;</span><br><span class="line">             Background=&quot;#d7d7d7&quot; x:Name=&quot;userControl&quot;</span><br><span class="line">             prism:ViewModelLocator.AutoWireViewModel=&quot;True&quot;&gt;</span><br><span class="line">    &lt;UserControl.Resources&gt;</span><br><span class="line">        &lt;DataTemplate x:Key=&quot;CanIdTemplate&quot; DataType=&quot;&#123;x:Type sys:String&#125;&quot;&gt;</span><br><span class="line">            &lt;materialDesign:Chip Content=&quot;&#123;Binding&#125;&quot; Margin=&quot;5,5,0,0&quot;</span><br><span class="line">                                 IsDeletable=&quot;True&quot;</span><br><span class="line">                                 DeleteCommand=&quot;&#123;Binding ElementName=userControl, Path=DataContext.CanIdChipDeleteCommand&#125;&quot;</span><br><span class="line">                                 DeleteCommandParameter=&quot;&#123;Binding&#125;&quot;&gt;</span><br><span class="line">            &lt;/materialDesign:Chip&gt;</span><br><span class="line">        &lt;/DataTemplate&gt;</span><br><span class="line">    &lt;/UserControl.Resources&gt;</span><br><span class="line">&lt;/UserControl&gt;</span><br></pre></td></tr></table></figure></p><p>代码修改如上后，可以正确触发 <code>ViewModel</code> 中的 <code>CanIdChipDeleteCommand</code> 命令了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天使用wpf的prism开发项目时，需要有在ListBox中的ListBoxItem触发命令的需求，&lt;br&gt;在创建ListBoxItem的DataTemplate时，将prism的viewmodel中定义的command绑定到DataTemplate的Command上，&lt;br&gt;如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;DataTemplate x:Key=&amp;quot;CanIdTemplate&amp;quot; DataType=&amp;quot;&amp;#123;x:Type sys:String&amp;#125;&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;materialDesign:Chip Content=&amp;quot;&amp;#123;Binding&amp;#125;&amp;quot; Margin=&amp;quot;5,5,0,0&amp;quot; IsDeletable=&amp;quot;True&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                         DeleteCommand=&amp;quot;&amp;#123;Binding CanIdChipDeleteCommand&amp;#125;&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/materialDesign:Chip&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/DataTemplate&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但在运行时发现 &lt;code&gt;CanIdChipDeleteCommand&lt;/code&gt; 没有触发。&lt;br&gt;
    
    </summary>
    
    
      <category term="prism" scheme="https://zhengxin23.github.io/tags/prism/"/>
    
      <category term="wpf" scheme="https://zhengxin23.github.io/tags/wpf/"/>
    
  </entry>
  
  <entry>
    <title>一条路</title>
    <link href="https://zhengxin23.github.io/2019/04/26/20190425-thoughtsOfOneRoad/"/>
    <id>https://zhengxin23.github.io/2019/04/26/20190425-thoughtsOfOneRoad/</id>
    <published>2019-04-26T02:14:43.000Z</published>
    <updated>2019-04-26T02:35:02.082Z</updated>
    
    <content type="html"><![CDATA[<p>对一条路的认识从陌生到熟悉后，<br>有时候会有一种怀念当初陌生的感觉。<br>因为那时在这条路上，<br>才刚开始，一切都值得憧憬。<br>因为那时在这条路上，<br>感觉生涩，一切都值得好奇。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对一条路的认识从陌生到熟悉后，&lt;br&gt;有时候会有一种怀念当初陌生的感觉。&lt;br&gt;因为那时在这条路上，&lt;br&gt;才刚开始，一切都值得憧憬。&lt;br&gt;因为那时在这条路上，&lt;br&gt;感觉生涩，一切都值得好奇。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="随记" scheme="https://zhengxin23.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>dbKoda连接mongodb出现ConnectNamedPipe Failed错误</title>
    <link href="https://zhengxin23.github.io/2019/04/16/20190416-dbKoda%E8%BF%9E%E6%8E%A5mongodb%E5%87%BA%E9%94%99/"/>
    <id>https://zhengxin23.github.io/2019/04/16/20190416-dbKoda连接mongodb出错/</id>
    <published>2019-04-16T11:09:57.000Z</published>
    <updated>2019-04-16T11:23:24.923Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近使用 dbKoda 连接 mongodb 数据库出现错误</p></blockquote><h3 id="1-dbKoda连接mongodb出现ConnectNamedPipe-Failed错误"><a href="#1-dbKoda连接mongodb出现ConnectNamedPipe-Failed错误" class="headerlink" title="1. dbKoda连接mongodb出现ConnectNamedPipe Failed错误"></a>1. dbKoda连接mongodb出现ConnectNamedPipe Failed错误</h3><p>出错提示如下：<br>Error lauching WinPTY agent : ConnectNamedPipe failed:<br>Window error 232 at new WindowsPtyAgent(……)<br><a id="more"></a><br><img src="https://i.loli.net/2019/04/16/5cb5b7c5bfd2b.png" alt></p><h3 id="2-关闭-McAfee-实时保护功能后连接成功"><a href="#2-关闭-McAfee-实时保护功能后连接成功" class="headerlink" title="2. 关闭 McAfee 实时保护功能后连接成功"></a>2. 关闭 McAfee 实时保护功能后连接成功</h3><p>经各种方法尝试后，发现关闭 McAfee 实时保护功能后，连接成功</p><p><img src="https://i.loli.net/2019/04/16/5cb5b7c2d2911.png" alt> </p><p><img src="https://i.loli.net/2019/04/16/5cb5b7c5bbb1b.png" alt> </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近使用 dbKoda 连接 mongodb 数据库出现错误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-dbKoda连接mongodb出现ConnectNamedPipe-Failed错误&quot;&gt;&lt;a href=&quot;#1-dbKoda连接mongodb出现ConnectNamedPipe-Failed错误&quot; class=&quot;headerlink&quot; title=&quot;1. dbKoda连接mongodb出现ConnectNamedPipe Failed错误&quot;&gt;&lt;/a&gt;1. dbKoda连接mongodb出现ConnectNamedPipe Failed错误&lt;/h3&gt;&lt;p&gt;出错提示如下：&lt;br&gt;Error lauching WinPTY agent : ConnectNamedPipe failed:&lt;br&gt;Window error 232 at new WindowsPtyAgent(……)&lt;br&gt;
    
    </summary>
    
    
      <category term="mongodb" scheme="https://zhengxin23.github.io/tags/mongodb/"/>
    
      <category term="dbKoda" scheme="https://zhengxin23.github.io/tags/dbKoda/"/>
    
  </entry>
  
  <entry>
    <title>《微信小程序运营实战》的阅读感想</title>
    <link href="https://zhengxin23.github.io/2019/04/08/20190402-read-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%90%A5%E5%AE%9E%E6%88%98/"/>
    <id>https://zhengxin23.github.io/2019/04/08/20190402-read-微信小程序运营实战/</id>
    <published>2019-04-08T12:00:00.000Z</published>
    <updated>2019-04-08T12:04:02.386Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>page 136</p><blockquote><p>例如，张小龙介绍小程序时提到的汽车站购票场景中，用户扫描小程序二维码的概率远高于线上。这其实相当于购票小程序分享了汽车客运站所独占的用户时间，从而使用户更愿意关注和使用此种场景下的小程序。</p></blockquote></blockquote><p>抢占用户线下的时间片段，同时满足将商业致于无形的理念。</p><blockquote><p>page 167</p><blockquote><p>很多人一辈子都未必会去电影院看一场电影或者去演唱会现场听音乐，这也并非是因为他们的购买力较低，而是因为他们更喜欢在乘坐公交车、排队付款等碎片化的场景中随时随地地获取这些内容。例如，部分人喜欢在洗澡的时候听音乐，部分人喜欢在乘坐公交车时看动漫，还有人喜欢边吃饭边看视频……将自己感兴趣的内容与生活场景进行搭配并组合后，可以让他们的生活变得更加丰富多彩。</p></blockquote></blockquote><p>当代人生活中碎片化的时间越来越普遍，小程序的轻快特性正好适合嵌入到这些碎片时间里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;page 136&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如，张小龙介绍小程序时提到的汽车站购票场景中，用户扫描小程序二维码的概率远高于线上。这其实相当于购票小程序分享了汽车客运站所独占的用户时间，从而使用户更愿意关注和使用此种场景下的小程序。&lt;
      
    
    </summary>
    
    
      <category term="读书" scheme="https://zhengxin23.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>第一次创建.NetCore控制台程序编译失败问题</title>
    <link href="https://zhengxin23.github.io/2019/04/07/20190407-dotnetcore-app-first/"/>
    <id>https://zhengxin23.github.io/2019/04/07/20190407-dotnetcore-app-first/</id>
    <published>2019-04-07T02:16:26.000Z</published>
    <updated>2019-04-11T12:53:15.883Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>随着微软对.NetCore的不断推进发展，作为.Net阵营的开发人员，开始着手跟上脚步学习.NetCore</p></blockquote><h3 id="创建-NetCore-控制台程序"><a href="#创建-NetCore-控制台程序" class="headerlink" title="创建 .NetCore 控制台程序"></a>创建 .NetCore 控制台程序</h3><p>第一次创建控制台程序，编译时出现了如下问题,<br>依赖项出现黄色叹号警告，很多程序库未引用。有点让人摸不着头脑，想首次来个”hello, world”就给抛出难题<br><a id="more"></a><br><img src="https://i.loli.net/2019/04/07/5ca95e569a634.png" alt></p><p>其中一项错误为：</p><blockquote><p>找不到资产文件”…\project.assets.json”。运行NuGet包还原以生成此文件。</p></blockquote><p>猜想应该与 NuGet 程序包管理问题相关。</p><h3 id="dotnet-命令创建控制台程序"><a href="#dotnet-命令创建控制台程序" class="headerlink" title="dotnet 命令创建控制台程序"></a>dotnet 命令创建控制台程序</h3><p>dotnet命令创建控制台项目三步曲：</p><ul><li><code>dotnet new console - o netcore2</code></li><li><code>dotnet restore netcore2\netcore2.csproj</code></li><li><code>dotnet run -p netcore2\netcore2.csproj</code></li></ul><p>使用命令创建的项目能正常编译运行<br><img src="https://i.loli.net/2019/04/07/5ca9608cf143f.png" alt="dotnetcore4.png"></p><p>查看命令行与vs创建项目的过程，有区别的可能为第二步：<br><code>dotnet restore</code> - 恢复项目的依赖项和工具。</p><p>用该命令应用于用vs创建的控制台项目后，可以正常编译及执行了。<br>但按道理不可能每次使用vs创建项目都需要使用命令行执行<code>dotnet restore</code>一下吧，<br>这也太麻烦了。</p><h3 id="NuGet-包管理器设置"><a href="#NuGet-包管理器设置" class="headerlink" title="NuGet 包管理器设置"></a>NuGet 包管理器设置</h3><p>几经周折，找到原来vs上有设置程序包还原的选项，可以依据项目自动恢复依赖项和工具。<br><img src="https://i.loli.net/2019/04/07/5ca95e5675066.png" alt="dotnetcore2.png"><br>将如上图的两个选项勾选-确定。</p><h3 id="终于编译并执行成功"><a href="#终于编译并执行成功" class="headerlink" title="终于编译并执行成功"></a>终于编译并执行成功</h3><p>NuGet包管理器设置好后，“重新生成”控制台项目，终于可以编译和执行成功了。<br><img src="https://i.loli.net/2019/04/07/5ca95e5695cb9.png" alt="dotnetcore3.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>不知道VS为什么不自动勾选后这两个选项，让开发人员省点心……</li><li>Hello .NetCore 解锁完成</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;随着微软对.NetCore的不断推进发展，作为.Net阵营的开发人员，开始着手跟上脚步学习.NetCore&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;创建-NetCore-控制台程序&quot;&gt;&lt;a href=&quot;#创建-NetCore-控制台程序&quot; class=&quot;headerlink&quot; title=&quot;创建 .NetCore 控制台程序&quot;&gt;&lt;/a&gt;创建 .NetCore 控制台程序&lt;/h3&gt;&lt;p&gt;第一次创建控制台程序，编译时出现了如下问题,&lt;br&gt;依赖项出现黄色叹号警告，很多程序库未引用。有点让人摸不着头脑，想首次来个”hello, world”就给抛出难题&lt;br&gt;
    
    </summary>
    
    
      <category term=".NetCore" scheme="https://zhengxin23.github.io/tags/NetCore/"/>
    
  </entry>
  
  <entry>
    <title>.Net性能测试工具BenchmarkDotnet</title>
    <link href="https://zhengxin23.github.io/2019/04/06/20190406-benchmarkDotnet/"/>
    <id>https://zhengxin23.github.io/2019/04/06/20190406-benchmarkDotnet/</id>
    <published>2019-04-06T01:46:26.000Z</published>
    <updated>2019-04-07T01:41:05.499Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>性能基准测试可以帮助程序员对比2个代码段或者方法的性能，这对于代码重写或者重构来说，可以提供一种很好的量化标准。如果没有性能基准测试，很难想象将方法A改为B方法时候，仅凭肉眼如何区分性能的变化。</p></blockquote><h3 id="BenchmarkDotNet"><a href="#BenchmarkDotNet" class="headerlink" title="BenchmarkDotNet"></a>BenchmarkDotNet</h3><p>BenchmarkDotNet是一款强力的.Net性能基准测试库，官网 <a href="https://benchmarkdotnet.org/" target="_blank" rel="noopener">https://benchmarkdotnet.org/</a>。<br>运行时支持<br><a id="more"></a></p><ul><li>NET Framework (4.6+),</li><li>.NET Core (2.0+)</li><li>Mono</li><li>CoreRT。</li></ul><p>BenchmarkDotnet为每个被测试的方法提供了孤立的环境, 使用BenchmarkDotnet, 程序员可以很容易的编写各种性能测试方法，并可以避免许多常见的坑。</p><h3 id="代码基准测试-Code-Benchmarking"><a href="#代码基准测试-Code-Benchmarking" class="headerlink" title="代码基准测试(Code Benchmarking)"></a>代码基准测试(Code Benchmarking)</h3><p>现在我们希望来对比一下Linq to object中First和Single方法的性能</p><blockquote><p>虽然我们知道First的性能肯定比Single高, First方法会在查询到第一个满足条件的对象之后就停止集合遍历，而Single找到第一个满足条件的对象之后，不会停止查找，它会去继续查找集合中的剩余对象，直到遍历整个集合或者在集合中找到第二个匹配条件的对象。 这里我们只是为了演示一下如何进行代码基准测试。</p></blockquote><p>为了使用BenchmarkDotNet来进行代码基准测试，我们首先创建一个空的.Net Core控制台程序。</p><p><img src="https://upload-images.jianshu.io/upload_images/14183497-2b402ba1a47593e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/955/format/webp" alt></p><p>然后我们使用Package Manage Console添加BenchmarkDotNet库</p><p><code>PM&gt; Install-Package BenchmarkDotNet</code></p><p>然后我们修改Program.cs文件, 代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Program</span><br><span class="line">&#123;</span><br><span class="line">    public class SingleVsFirst</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly List&lt;string&gt; _haystack = new List&lt;string&gt;();</span><br><span class="line">        private readonly int _haystackSize = 1000000;</span><br><span class="line">        private readonly string _needle = &quot;needle&quot;;</span><br><span class="line"></span><br><span class="line">        public SingleVsFirst()</span><br><span class="line">        &#123;</span><br><span class="line">            //Add a large amount of items to our list. </span><br><span class="line">            Enumerable.Range(1, _haystackSize).ToList().ForEach(x =&gt; _haystack.Add(x.ToString()));</span><br><span class="line">            //Insert the needle right in the middle. </span><br><span class="line">            _haystack.Insert(_haystackSize / 2, _needle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [Benchmark]</span><br><span class="line">        public string Single() =&gt; _haystack.SingleOrDefault(x =&gt; x == _needle);</span><br><span class="line"></span><br><span class="line">        [Benchmark]</span><br><span class="line">        public string First() =&gt; _haystack.FirstOrDefault(x =&gt; x == _needle);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        var summary = BenchmarkRunner.Run&lt;SingleVsFirst&gt;();</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 代码解释说明 </strong></p><ul><li>以上代码中<code>SingleVsFtirs</code>类是一个测试类。</li><li>测试类中我们生成了一个拥有100万对象的字符串集合。</li><li>我们在集合的中间位置插入了一个测试字符串，字符串的内容是”needle”。</li><li>代码中的<code>Single</code>和<code>First</code>方法，分别调用了Linq to - object的<code>SingleOrDefault</code>和<code>FirstOrDefault</code>方法- 来查询字符串集合中的”needle”字符串。</li><li>在<code>Single</code>和<code>First</code>方法上，我们加入<code>[Benchmark]</code>特性, 拥有该特性的方法会出现在最后的基准检测报告中。</li></ul><blockquote><p>注意：</p><ul><li>测试的方法必须是公开的(public), 如果把public去掉，程序不会产生任何结果</li><li>在运行程序之前，还有一步关键的操作，测试的程序需要使用Release模式编译，并且不能附加任何调试器(Debugger)</li></ul></blockquote><h3 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h3><p>现在我们运行程序，程序产生的最终报告如下</p><table><thead><tr><th>Method</th><th style="text-align:right">Mean</th><th style="text-align:right">Error</th><th style="text-align:right">StdDev</th><th style="text-align:right">Median</th></tr></thead><tbody><tr><td>Single</td><td style="text-align:right">28.12 ms</td><td style="text-align:right">0.9347 ms</td><td style="text-align:right">2.697 ms</td><td style="text-align:right">28.93 ms</td></tr><tr><td>First</td><td style="text-align:right">13.30 ms</td><td style="text-align:right">0.8394 ms</td><td style="text-align:right">2.475 ms</td><td style="text-align:right">14.48 ms</td></tr></tbody></table><h3 id="带测试参数的基准测试-Input-Benchmarking"><a href="#带测试参数的基准测试-Input-Benchmarking" class="headerlink" title="带测试参数的基准测试(Input Benchmarking)"></a>带测试参数的基准测试(Input Benchmarking)</h3><p>BenchmarkDotNet中我们还可以使用<code>[ParamsSource]</code>参数来指定测试的用例范围。<br>在上面的代码中，我们测试了匹配字符串在集合中间位置时，<code>First</code>和<code>Single</code>的效率对比，下面我们修改上面的代码，我们希望分别测试匹配字符串在集合头部，尾部以及中间位置时<code>First</code>和<code>Single</code>的效率对比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line"> </span><br><span class="line">using BenchmarkDotNet.Attributes;</span><br><span class="line">using BenchmarkDotNet.Running;</span><br><span class="line"> </span><br><span class="line">namespace BenchmarkExample</span><br><span class="line">&#123;</span><br><span class="line">    public class SingleVsFirst</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly List&lt;string&gt; _haystack = new List&lt;string&gt;();</span><br><span class="line">        private readonly int _haystackSize = 1000000;</span><br><span class="line"> </span><br><span class="line">        public List&lt;string&gt; _needles =&gt; new List&lt;string&gt; &#123; &quot;StartNeedle&quot;, &quot;MiddleNeedle&quot;, &quot;EndNeedle&quot; &#125;;</span><br><span class="line"> </span><br><span class="line">        public SingleVsFirst()</span><br><span class="line">        &#123;</span><br><span class="line">            //Add a large amount of items to our list. </span><br><span class="line">            Enumerable.Range(1, _haystackSize).ToList().ForEach(x =&gt; _haystack.Add(x.ToString()));</span><br><span class="line"> </span><br><span class="line">            //One at the start. </span><br><span class="line">            _haystack.Insert(0, _needles[0]);</span><br><span class="line">            //One right in the middle. </span><br><span class="line">            _haystack.Insert(_haystackSize / 2, _needles[1]);</span><br><span class="line">            //One at the end. </span><br><span class="line">            _haystack.Insert(_haystack.Count - 1, _needles[2]);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        [ParamsSource(nameof(_needles))]</span><br><span class="line">        public string Needle &#123; get; set; &#125;</span><br><span class="line"> </span><br><span class="line">        [Benchmark]</span><br><span class="line">        public string Single() =&gt; _haystack.SingleOrDefault(x =&gt; x == Needle);</span><br><span class="line"> </span><br><span class="line">        [Benchmark]</span><br><span class="line">        public string First() =&gt; _haystack.FirstOrDefault(x =&gt; x == Needle);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            var summary = BenchmarkRunner.Run&lt;SingleVsFirst&gt;();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 代码解释说明 </strong></p><ul><li>我们创建了测试的用例字符串集合<code>_needles</code></li><li>在构造函数中，我们在字符串集合的头部，中部，尾部分别插入了3个字符串</li><li>我们添加了一个属性<code>Needle</code>, 表示当前测试的用例，在被测试<code>Single</code>和<code>First</code>方法中，我们使用属性<code>Needle</code>来匹配</li><li>在属性Needle上我们加上了参数来源特性<code>[ParamsSource]</code>, 并设置参数来源是<code>_needles</code></li></ul><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>现在我们运行程序，程序产生的最终报告如下</p><table><thead><tr><th>Method</th><th>Needle</th><th style="text-align:right">Mean</th><th style="text-align:right">Error</th><th style="text-align:right">StdDev</th><th style="text-align:right">Median</th></tr></thead><tbody><tr><td>Single</td><td>EndNeedle</td><td style="text-align:right">23,266,757.53 ns</td><td style="text-align:right">432,206.593 ns</td><td style="text-align:right">591,609.263 ns</td><td style="text-align:right">23,236,343.07 ns</td></tr><tr><td>First</td><td>EndNeedle</td><td style="text-align:right">24,984,621.12 ns</td><td style="text-align:right">494,223.345 ns</td><td style="text-align:right">783,890.599 ns</td><td style="text-align:right">24,936,945.21 ns</td></tr><tr><td>Single</td><td>MiddleNeedle</td><td style="text-align:right">21,379,814.14 ns</td><td style="text-align:right">806,253.579 ns</td><td style="text-align:right">2,377,256.870 ns</td><td style="text-align:right">22,436,101.14 ns</td></tr><tr><td>First</td><td>MiddleNeedle</td><td style="text-align:right">11,984,519.09 ns</td><td style="text-align:right">315,184.021 ns</td><td style="text-align:right">924,380.173 ns</td><td style="text-align:right">12,233,700.94 ns</td></tr><tr><td>Single</td><td>StartNeedle</td><td style="text-align:right">23,650,243.23 ns</td><td style="text-align:right">599,968.173 ns</td><td style="text-align:right">714,219.431 ns</td><td style="text-align:right">23,555,402.19 ns</td></tr><tr><td>First</td><td>StartNeedle</td><td style="text-align:right">89.17 ns</td><td style="text-align:right">1.864 ns</td><td style="text-align:right">2.732 ns</td><td style="text-align:right">89.07 ns</td></tr></tbody></table><p>从结果上看</p><ul><li>当匹配字符串在集合头部的时候，<code>First</code>性能比<code>Single</code>高的多</li><li>当匹配字符串在集合中部的时候，<code>First</code>性能是比<code>Single</code>的一倍</li><li>当匹配字符串在集合尾部的时候，<code>First</code>和比<code>Single</code>的性能差不多</li></ul><h3 id="加入内存测试"><a href="#加入内存测试" class="headerlink" title="加入内存测试"></a>加入内存测试</h3><p>在.NET Core中的CSV解析库中，我们使用了以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[MemoryDiagnoser]</span><br><span class="line">    public class CsvBenchmarking</span><br><span class="line">    &#123;</span><br><span class="line">        [Benchmark(Baseline =true)]</span><br><span class="line">        public IEnumerable&lt;Automobile&gt; CSVHelper()</span><br><span class="line">        &#123;</span><br><span class="line">            TextReader reader = new StreamReader(&quot;import.txt&quot;);</span><br><span class="line">            var csvReader = new CsvReader(reader);</span><br><span class="line">            var records = csvReader.GetRecords&lt;Automobile&gt;();</span><br><span class="line">            return records.ToList();</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        [Benchmark]</span><br><span class="line">        public IEnumerable&lt;Automobile&gt; TinyCsvParser()</span><br><span class="line">        &#123;</span><br><span class="line">            CsvParserOptions csvParserOptions = new CsvParserOptions(true, &apos;,&apos;);</span><br><span class="line">            var csvParser = new CsvParser&lt;Automobile&gt;(csvParserOptions, new CsvAutomobileMapping());</span><br><span class="line">     </span><br><span class="line">            var records = csvParser.ReadFromFile(&quot;import.txt&quot;, Encoding.UTF8);</span><br><span class="line">     </span><br><span class="line">            return records.Select(x =&gt; x.Result).ToList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中除了<code>[Benchmark]</code>特性，我们还在测试类<code>CsvBenchmarking</code>上添加了<code>[MemoryDiagnoser]</code>特性，该特性会在测试报告中追加，2个方法执行时的内存使用情况。</p><table><thead><tr><th>Method</th><th style="text-align:right">Mean</th><th style="text-align:right">Scaled</th><th style="text-align:right">Allocated</th></tr></thead><tbody><tr><td>CSVHelper</td><td style="text-align:right">1,404.5 ms</td><td style="text-align:right">1.00</td><td style="text-align:right">244.39 MB</td></tr><tr><td>TinyCsvParser</td><td style="text-align:right">381.6 ms</td><td style="text-align:right">0.27</td><td style="text-align:right">32.53 MB</td></tr></tbody></table><p> 其中Allocated表明了内存占用情况。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> BenchmarkDotNet绝对是.NET开发人员了解代码性能，以及对比代码性能的必备神器。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;性能基准测试可以帮助程序员对比2个代码段或者方法的性能，这对于代码重写或者重构来说，可以提供一种很好的量化标准。如果没有性能基准测试，很难想象将方法A改为B方法时候，仅凭肉眼如何区分性能的变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;BenchmarkDotNet&quot;&gt;&lt;a href=&quot;#BenchmarkDotNet&quot; class=&quot;headerlink&quot; title=&quot;BenchmarkDotNet&quot;&gt;&lt;/a&gt;BenchmarkDotNet&lt;/h3&gt;&lt;p&gt;BenchmarkDotNet是一款强力的.Net性能基准测试库，官网 &lt;a href=&quot;https://benchmarkdotnet.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://benchmarkdotnet.org/&lt;/a&gt;。&lt;br&gt;运行时支持&lt;br&gt;
    
    </summary>
    
    
      <category term=".Net" scheme="https://zhengxin23.github.io/tags/Net/"/>
    
      <category term="性能" scheme="https://zhengxin23.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="BenchmarkDotnet" scheme="https://zhengxin23.github.io/tags/BenchmarkDotnet/"/>
    
  </entry>
  
  <entry>
    <title>ant-design-pro脚手架第一次使用及问题</title>
    <link href="https://zhengxin23.github.io/2019/04/05/20190405-ant-design-pro%E8%84%9A%E6%89%8B%E6%9E%B6%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E5%8F%8A%E9%97%AE%E9%A2%98/"/>
    <id>https://zhengxin23.github.io/2019/04/05/20190405-ant-design-pro脚手架第一次使用及问题/</id>
    <published>2019-04-05T12:27:07.000Z</published>
    <updated>2019-04-11T12:52:58.346Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近计划开发一个中后台平台，学习研究了一段时间 react<br>技术栈，感觉其以组件为核心思想的开发思路，有助于构建可复用的、相对易于维护的系统。由于UI设计方面比较薄弱，想依靠大平台的UI框架。查看了圈，感觉阿里的<br>Ant Design<br>挺符合心水。依靠大平台的设计理念，避免个人用户体验设计理念不足，避免个人开发出来的系统体验东一个想法西一个想法，导致系统体验太不专业。研究了一个<br>ant-design-pro 感觉不错。<br><a id="more"></a><br>开始着手搭建ant-design-pro demo工程，熟悉下。依据官网看似简单的步骤，但在过程中遇到一些莫名的问题，搞了两三天终于运行成功了……</p></blockquote><ol><li><p>参照官网步骤<br> github：<a href="https://github.com/ant-design/ant-design-pro" target="_blank" rel="noopener">https://github.com/ant-design/ant-design-pro</a><br> demo搭建步骤如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ant-design/ant-design-pro.git --depth=1</span><br><span class="line">cd ant-design-pro</span><br><span class="line">npm install</span><br><span class="line">npm start         # visit http://localhost:8000</span><br></pre></td></tr></table></figure></li><li><p>在 <code>npm install</code> 步骤时，一直出现各种依赖包安装失败等等等等等等各种摸不着头脑的问题<br> 如：某个依赖包无法安装、json解析出错等。<br> 如：npm ERR! Error: EPERM: operation not permitted, 使用管理员权限也解决不了<br> 忘记截图保存了，自己脑补下吧~~<br> 如失败提示网上搜索，基本都没有很准确的解决方法。</p></li><li><p>最后通过将 npm 降到版本4后，终于安装部署成功了，汗。<br> 原先安装时，为版本8；中间试过降到版本6也不行。<br> npm降版本命令： <code>npm i npm@4 -g</code></p></li></ol><p>总结这种前端框架，有点不好就是依赖项目太多，每个依赖项目的版本已很多。<br>在版本不匹配时，出现一些莫名其妙的问题，如果很方便的路径进行解决！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近计划开发一个中后台平台，学习研究了一段时间 react&lt;br&gt;技术栈，感觉其以组件为核心思想的开发思路，有助于构建可复用的、相对易于维护的系统。由于UI设计方面比较薄弱，想依靠大平台的UI框架。查看了圈，感觉阿里的&lt;br&gt;Ant Design&lt;br&gt;挺符合心水。依靠大平台的设计理念，避免个人用户体验设计理念不足，避免个人开发出来的系统体验东一个想法西一个想法，导致系统体验太不专业。研究了一个&lt;br&gt;ant-design-pro 感觉不错。&lt;br&gt;
    
    </summary>
    
    
      <category term="react" scheme="https://zhengxin23.github.io/tags/react/"/>
    
      <category term="ant-design" scheme="https://zhengxin23.github.io/tags/ant-design/"/>
    
  </entry>
  
  <entry>
    <title>将已有项目绑定到git上</title>
    <link href="https://zhengxin23.github.io/2019/04/01/2019040101-git-create-repository/"/>
    <id>https://zhengxin23.github.io/2019/04/01/2019040101-git-create-repository/</id>
    <published>2019-04-01T13:54:00.000Z</published>
    <updated>2019-04-02T07:47:42.304Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-创建远程仓库"><a href="#1-创建远程仓库" class="headerlink" title="1. 创建远程仓库"></a><strong>1. 创建远程仓库</strong></h3><ul><li>登录github，在上边创建一个仓库</li><li>复制仓库链接，比如为<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:alex-my/some-project.git </li></ul><a id="more"></a><h3 id="2-初始化本地仓库"><a href="#2-初始化本地仓库" class="headerlink" title="2.初始化本地仓库"></a><strong>2.初始化本地仓库</strong></h3><p>进入本地项目执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 初始化本地仓库</span><br><span class="line">git init</span><br><span class="line">// 添加全部文件</span><br><span class="line">git add .</span><br><span class="line">// 提交到本地仓库</span><br><span class="line">git commit -m “提交说明”</span><br></pre></td></tr></table></figure></p><h3 id="3-本地仓库与远程仓库绑定"><a href="#3-本地仓库与远程仓库绑定" class="headerlink" title="3.本地仓库与远程仓库绑定"></a><strong>3.本地仓库与远程仓库绑定</strong></h3><p>绑定到远程仓库，并提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 绑定，并取一个别名，通常用origin，后面的地址是前边创建的远程仓库地址</span><br><span class="line">git remote add origin git@github.com:alex-my/some-project.git</span><br><span class="line">// 把本地仓库地址提交到远程仓库</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><h3 id="4-修改本地仓库，并提交到远程仓库"><a href="#4-修改本地仓库，并提交到远程仓库" class="headerlink" title="4.修改本地仓库，并提交到远程仓库"></a><strong>4.修改本地仓库，并提交到远程仓库</strong></h3><p>假设修改了README.md文件<br>在根目录或者在文件所在目录执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">// 查看变动</span><br><span class="line">git status</span><br><span class="line">// 提交到本地仓库</span><br><span class="line">git commit -m “modify reade.md”</span><br><span class="line">// 如果是多人合作的项目,请先pull</span><br><span class="line">git pull</span><br><span class="line">// 推送到远程仓库(第一个使用默认,作用和第一个一样)</span><br><span class="line">git push</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><h3 id="5-仓库别名"><a href="#5-仓库别名" class="headerlink" title="5.仓库别名"></a><strong>5.仓库别名</strong></h3><p>如果有多个仓库或者多个分支，在推送或者拉取的时候需要注意<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull 仓库别名 仓库分支</span><br><span class="line">git push 仓库别名 仓库分支</span><br></pre></td></tr></table></figure></p><h3 id="遇到问题-如下图"><a href="#遇到问题-如下图" class="headerlink" title="遇到问题,如下图"></a><strong>遇到问题,如下图</strong></h3><p><img src="https://i.loli.net/2019/04/01/5ca21a42539ac.png" alt><br>解决方法：git push -f origin master</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-创建远程仓库&quot;&gt;&lt;a href=&quot;#1-创建远程仓库&quot; class=&quot;headerlink&quot; title=&quot;1. 创建远程仓库&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 创建远程仓库&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;登录github，在上边创建一个仓库&lt;/li&gt;
&lt;li&gt;复制仓库链接，比如为&lt;a href=&quot;mailto:git@github.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git@github.com&lt;/a&gt;:alex-my/some-project.git &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="git" scheme="https://zhengxin23.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>python函数参数前面单星号（*）和双星号（**）的区别</title>
    <link href="https://zhengxin23.github.io/2019/03/05/20190305-python-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%89%8D%E9%9D%A2%E5%8D%95%E6%98%9F%E5%8F%B7%E5%92%8C%E5%8F%8C%E6%98%9F%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://zhengxin23.github.io/2019/03/05/20190305-python-函数参数前面单星号和双星号的区别/</id>
    <published>2019-03-05T12:30:00.000Z</published>
    <updated>2019-04-11T12:52:48.186Z</updated>
    
    <content type="html"><![CDATA[<p>在python的函数中经常能看到输入的参数前面有一个或者两个星号：例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def foo(param1, *param2):</span><br><span class="line">def bar(param1, **param2):</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>这两种用法其实都是用来将任意个数的参数导入到python函数中。</p><p>单星号（<em>）：</em>agrs<br>将所以参数以元组(tuple)的形式导入：<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def foo(param1, *param2):</span><br><span class="line">    print param1</span><br><span class="line">    print param2</span><br><span class="line">foo(1,2,3,4,5)</span><br></pre></td></tr></table></figure></p><p>1<br>(2, 3, 4, 5)<br>双星号（<strong>）：</strong>kwargs<br>将参数以字典的形式导入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def bar(param1, **param2):</span><br><span class="line">    print param1</span><br><span class="line">    print param2</span><br><span class="line">bar(1,a=2,b=3)</span><br></pre></td></tr></table></figure></p><p>1<br>{‘a’: 2, ‘b’: 3}<br>此外，单星号的另一个用法是解压参数列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def foo(bar, lee):</span><br><span class="line">    print bar, lee</span><br><span class="line">l = [1, 2]</span><br><span class="line">foo(*l)</span><br></pre></td></tr></table></figure></p><p>1 2<br>当然这两个用法可以同时出现在一个函数中：例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def foo(a, b=10, *args, **kwargs):</span><br><span class="line">    print a</span><br><span class="line">    print b</span><br><span class="line">    print args</span><br><span class="line">    print kwargs</span><br><span class="line">foo(1, 2, 3, 4, e=5, f=6, g=7)</span><br></pre></td></tr></table></figure></p><p>1<br>2<br>3 4<br>{‘e’: 5, ‘g’: 7, ‘f’: 6}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在python的函数中经常能看到输入的参数前面有一个或者两个星号：例如&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;def foo(param1, *param2):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def bar(param1, **param2):&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://zhengxin23.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序设置box-shadow阴影在真机上无效</title>
    <link href="https://zhengxin23.github.io/2019/01/06/20190106-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AEbox-shadow%E9%98%B4%E5%BD%B1%E5%9C%A8%E7%9C%9F%E6%9C%BA%E4%B8%8A%E6%97%A0%E6%95%88/"/>
    <id>https://zhengxin23.github.io/2019/01/06/20190106-微信小程序设置box-shadow阴影在真机上无效/</id>
    <published>2019-01-06T12:35:32.000Z</published>
    <updated>2019-04-11T12:52:40.698Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序设置box-shadow阴影无效，如下：</p><p><code>box-shadow: 0rpx 10rpx 50rpx 10rpx #5555551A;</code></p><p>在开发环境上有效，但在真机上无效。<br><a id="more"></a><br>解决办法：<br>使用rgba创建颜色后，在IDE和真机上都有效了。</p><p><code>box-shadow: 0rpx 10rpx 50rpx 10rpx rgba(85, 85, 85, 0.10);</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信小程序设置box-shadow阴影无效，如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;box-shadow: 0rpx 10rpx 50rpx 10rpx #5555551A;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在开发环境上有效，但在真机上无效。&lt;br&gt;
    
    </summary>
    
    
      <category term="微信小程序" scheme="https://zhengxin23.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序post请求服务器端 No HTTP resource was found 问题</title>
    <link href="https://zhengxin23.github.io/2018/11/30/20181130-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Fpost%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AFNo-HTTP-resource-was-found%E9%97%AE%E9%A2%98/"/>
    <id>https://zhengxin23.github.io/2018/11/30/20181130-微信小程序post请求服务器端No-HTTP-resource-was-found问题/</id>
    <published>2018-11-30T02:33:42.000Z</published>
    <updated>2019-04-11T12:52:25.530Z</updated>
    
    <content type="html"><![CDATA[<p>小程序端代码：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">      url: getApp().globalData.webApiUrlRoot + &apos;/api/User/test&apos;,</span><br><span class="line">      method: &apos;POST&apos;,</span><br><span class="line">      header: &#123;</span><br><span class="line">        &apos;content-type&apos;: &apos;application/json&apos; // 默认值</span><br><span class="line">      &#125;,</span><br><span class="line">      data:&#123;</span><br><span class="line">        a:&quot;1&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        console.log(res);</span><br><span class="line">      &#125;,</span><br><span class="line">      complete(res) &#123;</span><br><span class="line">        console.log(res);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>ASP.NET web api :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[HttpPost]</span><br><span class="line">public string test(string a)</span><br><span class="line">&#123;</span><br><span class="line">    return &quot;hello&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请求结果失败，应答内容：<br>“No HTTP resource was found that matches the request URI ‘<a href="http://localhost:57437/api/User/test&#39;.&quot;" target="_blank" rel="noopener">http://localhost:57437/api/User/test&#39;.&quot;</a></p><p>原因为：POST方法只能接收 Content-Type 为 application/x-www-form-urlencoded 和 multipart/form-data 的 POST 数据</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序端代码：&lt;br&gt;
    
    </summary>
    
    
      <category term="微信小程序" scheme="https://zhengxin23.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
</feed>
