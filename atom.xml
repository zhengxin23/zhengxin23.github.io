<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郑廿三</title>
  
  <subtitle>爱程序 | 爱读书 | 爱运动 | 爱生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhengxin23.github.io/"/>
  <updated>2019-05-06T12:44:10.811Z</updated>
  <id>https://zhengxin23.github.io/</id>
  
  <author>
    <name>zheng xin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序-云开发云调用API没有权限(no permission)问题</title>
    <link href="https://zhengxin23.github.io/2019/05/06/20190506-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BA%91%E5%BC%80%E5%8F%91%E4%BA%91%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <id>https://zhengxin23.github.io/2019/05/06/20190506-微信小程序-云开发云调用失败问题/</id>
    <published>2019-05-06T12:26:06.000Z</published>
    <updated>2019-05-06T12:44:10.811Z</updated>
    
    <content type="html"><![CDATA[<p>今天在学习微信小程序云开发中的在云函数中使用云调用api <code>templateMessage.send</code> 时，在开发环境中运行报错：function has no permission to call this API<br>如下图：<br><img src="https://i.loli.net/2019/05/06/5cd028aa7ff76.png" alt></p><a id="more"></a><p>查找总结原因大概有两点：</p><ol><li><p>云函数所在目录缺少个权限声明文件<br>config.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;permissions&quot;: &#123;</span><br><span class="line">    &quot;openapi&quot;: [&quot;templateMessage.send&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将微信开发工具升级到 v1.02.1904090 版本以上后，重新上传部署云函数</p></li></ol><p>解决如上两个问题后，运行正确<br><img src="https://i.loli.net/2019/05/06/5cd028aa3c647.png" alt></p><h2 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h2><p>在这过程中遇到另外一个问题，在云函数中调用 <code>templateMessage.send</code> 时，<br>云函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 云函数入口文件</span><br><span class="line">const cloud = require(&apos;wx-server-sdk&apos;)</span><br><span class="line">cloud.init()</span><br><span class="line">exports.main = async (event, context) =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    let formId = event.formId;</span><br><span class="line">    const result = await cloud.openapi.templateMessage.send(&#123;</span><br><span class="line">      touser: cloud.getWXContext().OPENID, // 通过 getWXContext 获取 OPENID</span><br><span class="line">      page: &apos;index&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        keyword1: &#123;</span><br><span class="line">          value: &apos;氢能总部&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        keyword2: &#123;</span><br><span class="line">          value: &apos;小明&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        keyword3: &#123;</span><br><span class="line">          value: &apos;18:00&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        keyword4: &#123;</span><br><span class="line">          value: &apos;云浮思劳&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      templateId: &apos;MYlxdani6r7yU0ldtZqadxxxxxxxxxxxxx&apos;,</span><br><span class="line">      formId: formId,</span><br><span class="line">      emphasisKeyword: &apos;keyword1.DATA&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    // result 结构</span><br><span class="line">    // &#123; errCode: 0, errMsg: &apos;openapi.templateMessage.send:ok&apos; &#125;</span><br><span class="line">    return result</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    // 错误处理</span><br><span class="line">    // err.errCode !== 0</span><br><span class="line">    throw err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在开发工具中报错：openapi.templateMessage.send:fail invalid form id hint<br>如下图：<br><img src="https://i.loli.net/2019/05/06/5cd028aa702ac.png" alt></p><p>经查找原因为：<br>在开发工具中支行时， <code>e.detail.formId</code> 的值为 <code>the formId is a mock one</code><br>这个值需要在真机调试中才会正常出现，点击真机调试，并在手机上再次点击这个功能按钮，果然打印了正常的 formId。使用开发工具中的”真机调试”运行成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在学习微信小程序云开发中的在云函数中使用云调用api &lt;code&gt;templateMessage.send&lt;/code&gt; 时，在开发环境中运行报错：function has no permission to call this API&lt;br&gt;如下图：&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/05/06/5cd028aa7ff76.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="微信小程序" scheme="https://zhengxin23.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>WPF ListBoxItem DataTemplate Command无效问题</title>
    <link href="https://zhengxin23.github.io/2019/04/30/20190430-wpf-listboxitem-datatemplate-command%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <id>https://zhengxin23.github.io/2019/04/30/20190430-wpf-listboxitem-datatemplate-command无效问题/</id>
    <published>2019-04-30T07:21:25.000Z</published>
    <updated>2019-04-30T07:50:14.162Z</updated>
    
    <content type="html"><![CDATA[<p>今天使用wpf的prism开发项目时，需要有在ListBox中的ListBoxItem触发命令的需求，<br>在创建ListBoxItem的DataTemplate时，将prism的viewmodel中定义的command绑定到DataTemplate的Command上，<br>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;DataTemplate x:Key=&quot;CanIdTemplate&quot; DataType=&quot;&#123;x:Type sys:String&#125;&quot;&gt;</span><br><span class="line">    &lt;materialDesign:Chip Content=&quot;&#123;Binding&#125;&quot; Margin=&quot;5,5,0,0&quot; IsDeletable=&quot;True&quot;</span><br><span class="line">                         DeleteCommand=&quot;&#123;Binding CanIdChipDeleteCommand&#125;&quot;&gt;</span><br><span class="line">    &lt;/materialDesign:Chip&gt;</span><br><span class="line">&lt;/DataTemplate&gt;</span><br></pre></td></tr></table></figure></p><p>但在运行时发现 <code>CanIdChipDeleteCommand</code> 没有触发。<br><a id="more"></a><br>然后将 <code>materialDesign:Chip</code> 单独放到其他控件容器里运行时可以正确触发命令。<br>经试验分析，应该是因为 DataTemplate 与 数据模板运行时加载所在的控件 的上下文是独立的，<br>而默认绑定情况下在prism的ViewModel中定义的<code>CanIdChipDeleteCommand</code>命令在 DataTemplate 中的上下文找不到。<br>可以通过修改绑定方式，将命令绑定的目标关联到与 ViewModel 所在的同一个上下文中。<br>修改代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserControl x:Class=&quot;VrmsServer.Desktop.Views.Functions.Configure.TboxCanIdSettingControl&quot;</span><br><span class="line">             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">             xmlns:prism=&quot;http://prismlibrary.com/&quot;</span><br><span class="line">             xmlns:materialDesign=&quot;http://materialdesigninxaml.net/winfx/xaml/themes&quot;</span><br><span class="line">             xmlns:i=&quot;http://schemas.microsoft.com/expression/2010/interactivity&quot;</span><br><span class="line">             xmlns:converter=&quot;clr-namespace:VrmsServer.Desktop.Converter&quot;</span><br><span class="line">             xmlns:sys=&quot;clr-namespace:System;assembly=mscorlib&quot;</span><br><span class="line">             Background=&quot;#d7d7d7&quot; x:Name=&quot;userControl&quot;</span><br><span class="line">             prism:ViewModelLocator.AutoWireViewModel=&quot;True&quot;&gt;</span><br><span class="line">    &lt;UserControl.Resources&gt;</span><br><span class="line">        &lt;DataTemplate x:Key=&quot;CanIdTemplate&quot; DataType=&quot;&#123;x:Type sys:String&#125;&quot;&gt;</span><br><span class="line">            &lt;materialDesign:Chip Content=&quot;&#123;Binding&#125;&quot; Margin=&quot;5,5,0,0&quot;</span><br><span class="line">                                 IsDeletable=&quot;True&quot;</span><br><span class="line">                                 DeleteCommand=&quot;&#123;Binding ElementName=userControl, Path=DataContext.CanIdChipDeleteCommand&#125;&quot;</span><br><span class="line">                                 DeleteCommandParameter=&quot;&#123;Binding&#125;&quot;&gt;</span><br><span class="line">            &lt;/materialDesign:Chip&gt;</span><br><span class="line">        &lt;/DataTemplate&gt;</span><br><span class="line">    &lt;/UserControl.Resources&gt;</span><br><span class="line">&lt;/UserControl&gt;</span><br></pre></td></tr></table></figure></p><p>代码修改如上后，可以正确触发 <code>ViewModel</code> 中的 <code>CanIdChipDeleteCommand</code> 命令了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天使用wpf的prism开发项目时，需要有在ListBox中的ListBoxItem触发命令的需求，&lt;br&gt;在创建ListBoxItem的DataTemplate时，将prism的viewmodel中定义的command绑定到DataTemplate的Command上，&lt;br&gt;如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;DataTemplate x:Key=&amp;quot;CanIdTemplate&amp;quot; DataType=&amp;quot;&amp;#123;x:Type sys:String&amp;#125;&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;materialDesign:Chip Content=&amp;quot;&amp;#123;Binding&amp;#125;&amp;quot; Margin=&amp;quot;5,5,0,0&amp;quot; IsDeletable=&amp;quot;True&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                         DeleteCommand=&amp;quot;&amp;#123;Binding CanIdChipDeleteCommand&amp;#125;&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/materialDesign:Chip&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/DataTemplate&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但在运行时发现 &lt;code&gt;CanIdChipDeleteCommand&lt;/code&gt; 没有触发。&lt;br&gt;
    
    </summary>
    
    
      <category term="prism" scheme="https://zhengxin23.github.io/tags/prism/"/>
    
      <category term="wpf" scheme="https://zhengxin23.github.io/tags/wpf/"/>
    
  </entry>
  
  <entry>
    <title>一条路</title>
    <link href="https://zhengxin23.github.io/2019/04/26/20190425-thoughtsOfOneRoad/"/>
    <id>https://zhengxin23.github.io/2019/04/26/20190425-thoughtsOfOneRoad/</id>
    <published>2019-04-26T02:14:43.000Z</published>
    <updated>2019-04-26T02:35:02.082Z</updated>
    
    <content type="html"><![CDATA[<p>对一条路的认识从陌生到熟悉后，<br>有时候会有一种怀念当初陌生的感觉。<br>因为那时在这条路上，<br>才刚开始，一切都值得憧憬。<br>因为那时在这条路上，<br>感觉生涩，一切都值得好奇。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对一条路的认识从陌生到熟悉后，&lt;br&gt;有时候会有一种怀念当初陌生的感觉。&lt;br&gt;因为那时在这条路上，&lt;br&gt;才刚开始，一切都值得憧憬。&lt;br&gt;因为那时在这条路上，&lt;br&gt;感觉生涩，一切都值得好奇。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="随记" scheme="https://zhengxin23.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>dbKoda连接mongodb出现ConnectNamedPipe Failed错误</title>
    <link href="https://zhengxin23.github.io/2019/04/16/20190416-dbKoda%E8%BF%9E%E6%8E%A5mongodb%E5%87%BA%E9%94%99/"/>
    <id>https://zhengxin23.github.io/2019/04/16/20190416-dbKoda连接mongodb出错/</id>
    <published>2019-04-16T11:09:57.000Z</published>
    <updated>2019-04-16T11:23:24.923Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近使用 dbKoda 连接 mongodb 数据库出现错误</p></blockquote><h3 id="1-dbKoda连接mongodb出现ConnectNamedPipe-Failed错误"><a href="#1-dbKoda连接mongodb出现ConnectNamedPipe-Failed错误" class="headerlink" title="1. dbKoda连接mongodb出现ConnectNamedPipe Failed错误"></a>1. dbKoda连接mongodb出现ConnectNamedPipe Failed错误</h3><p>出错提示如下：<br>Error lauching WinPTY agent : ConnectNamedPipe failed:<br>Window error 232 at new WindowsPtyAgent(……)<br><a id="more"></a><br><img src="https://i.loli.net/2019/04/16/5cb5b7c5bfd2b.png" alt></p><h3 id="2-关闭-McAfee-实时保护功能后连接成功"><a href="#2-关闭-McAfee-实时保护功能后连接成功" class="headerlink" title="2. 关闭 McAfee 实时保护功能后连接成功"></a>2. 关闭 McAfee 实时保护功能后连接成功</h3><p>经各种方法尝试后，发现关闭 McAfee 实时保护功能后，连接成功</p><p><img src="https://i.loli.net/2019/04/16/5cb5b7c2d2911.png" alt> </p><p><img src="https://i.loli.net/2019/04/16/5cb5b7c5bbb1b.png" alt> </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近使用 dbKoda 连接 mongodb 数据库出现错误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-dbKoda连接mongodb出现ConnectNamedPipe-Failed错误&quot;&gt;&lt;a href=&quot;#1-dbKoda连接mongodb出现ConnectNamedPipe-Failed错误&quot; class=&quot;headerlink&quot; title=&quot;1. dbKoda连接mongodb出现ConnectNamedPipe Failed错误&quot;&gt;&lt;/a&gt;1. dbKoda连接mongodb出现ConnectNamedPipe Failed错误&lt;/h3&gt;&lt;p&gt;出错提示如下：&lt;br&gt;Error lauching WinPTY agent : ConnectNamedPipe failed:&lt;br&gt;Window error 232 at new WindowsPtyAgent(……)&lt;br&gt;
    
    </summary>
    
    
      <category term="mongodb" scheme="https://zhengxin23.github.io/tags/mongodb/"/>
    
      <category term="dbKoda" scheme="https://zhengxin23.github.io/tags/dbKoda/"/>
    
  </entry>
  
  <entry>
    <title>《微信小程序运营实战》的阅读感想</title>
    <link href="https://zhengxin23.github.io/2019/04/08/20190402-read-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%90%A5%E5%AE%9E%E6%88%98/"/>
    <id>https://zhengxin23.github.io/2019/04/08/20190402-read-微信小程序运营实战/</id>
    <published>2019-04-08T12:00:00.000Z</published>
    <updated>2019-04-08T12:04:02.386Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>page 136</p><blockquote><p>例如，张小龙介绍小程序时提到的汽车站购票场景中，用户扫描小程序二维码的概率远高于线上。这其实相当于购票小程序分享了汽车客运站所独占的用户时间，从而使用户更愿意关注和使用此种场景下的小程序。</p></blockquote></blockquote><p>抢占用户线下的时间片段，同时满足将商业致于无形的理念。</p><blockquote><p>page 167</p><blockquote><p>很多人一辈子都未必会去电影院看一场电影或者去演唱会现场听音乐，这也并非是因为他们的购买力较低，而是因为他们更喜欢在乘坐公交车、排队付款等碎片化的场景中随时随地地获取这些内容。例如，部分人喜欢在洗澡的时候听音乐，部分人喜欢在乘坐公交车时看动漫，还有人喜欢边吃饭边看视频……将自己感兴趣的内容与生活场景进行搭配并组合后，可以让他们的生活变得更加丰富多彩。</p></blockquote></blockquote><p>当代人生活中碎片化的时间越来越普遍，小程序的轻快特性正好适合嵌入到这些碎片时间里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;page 136&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如，张小龙介绍小程序时提到的汽车站购票场景中，用户扫描小程序二维码的概率远高于线上。这其实相当于购票小程序分享了汽车客运站所独占的用户时间，从而使用户更愿意关注和使用此种场景下的小程序。&lt;
      
    
    </summary>
    
    
      <category term="读书" scheme="https://zhengxin23.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>第一次创建.NetCore控制台程序编译失败问题</title>
    <link href="https://zhengxin23.github.io/2019/04/07/20190407-dotnetcore-app-first/"/>
    <id>https://zhengxin23.github.io/2019/04/07/20190407-dotnetcore-app-first/</id>
    <published>2019-04-07T02:16:26.000Z</published>
    <updated>2019-04-11T12:53:15.883Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>随着微软对.NetCore的不断推进发展，作为.Net阵营的开发人员，开始着手跟上脚步学习.NetCore</p></blockquote><h3 id="创建-NetCore-控制台程序"><a href="#创建-NetCore-控制台程序" class="headerlink" title="创建 .NetCore 控制台程序"></a>创建 .NetCore 控制台程序</h3><p>第一次创建控制台程序，编译时出现了如下问题,<br>依赖项出现黄色叹号警告，很多程序库未引用。有点让人摸不着头脑，想首次来个”hello, world”就给抛出难题<br><a id="more"></a><br><img src="https://i.loli.net/2019/04/07/5ca95e569a634.png" alt></p><p>其中一项错误为：</p><blockquote><p>找不到资产文件”…\project.assets.json”。运行NuGet包还原以生成此文件。</p></blockquote><p>猜想应该与 NuGet 程序包管理问题相关。</p><h3 id="dotnet-命令创建控制台程序"><a href="#dotnet-命令创建控制台程序" class="headerlink" title="dotnet 命令创建控制台程序"></a>dotnet 命令创建控制台程序</h3><p>dotnet命令创建控制台项目三步曲：</p><ul><li><code>dotnet new console - o netcore2</code></li><li><code>dotnet restore netcore2\netcore2.csproj</code></li><li><code>dotnet run -p netcore2\netcore2.csproj</code></li></ul><p>使用命令创建的项目能正常编译运行<br><img src="https://i.loli.net/2019/04/07/5ca9608cf143f.png" alt="dotnetcore4.png"></p><p>查看命令行与vs创建项目的过程，有区别的可能为第二步：<br><code>dotnet restore</code> - 恢复项目的依赖项和工具。</p><p>用该命令应用于用vs创建的控制台项目后，可以正常编译及执行了。<br>但按道理不可能每次使用vs创建项目都需要使用命令行执行<code>dotnet restore</code>一下吧，<br>这也太麻烦了。</p><h3 id="NuGet-包管理器设置"><a href="#NuGet-包管理器设置" class="headerlink" title="NuGet 包管理器设置"></a>NuGet 包管理器设置</h3><p>几经周折，找到原来vs上有设置程序包还原的选项，可以依据项目自动恢复依赖项和工具。<br><img src="https://i.loli.net/2019/04/07/5ca95e5675066.png" alt="dotnetcore2.png"><br>将如上图的两个选项勾选-确定。</p><h3 id="终于编译并执行成功"><a href="#终于编译并执行成功" class="headerlink" title="终于编译并执行成功"></a>终于编译并执行成功</h3><p>NuGet包管理器设置好后，“重新生成”控制台项目，终于可以编译和执行成功了。<br><img src="https://i.loli.net/2019/04/07/5ca95e5695cb9.png" alt="dotnetcore3.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>不知道VS为什么不自动勾选后这两个选项，让开发人员省点心……</li><li>Hello .NetCore 解锁完成</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;随着微软对.NetCore的不断推进发展，作为.Net阵营的开发人员，开始着手跟上脚步学习.NetCore&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;创建-NetCore-控制台程序&quot;&gt;&lt;a href=&quot;#创建-NetCore-控制台程序&quot; class=&quot;headerlink&quot; title=&quot;创建 .NetCore 控制台程序&quot;&gt;&lt;/a&gt;创建 .NetCore 控制台程序&lt;/h3&gt;&lt;p&gt;第一次创建控制台程序，编译时出现了如下问题,&lt;br&gt;依赖项出现黄色叹号警告，很多程序库未引用。有点让人摸不着头脑，想首次来个”hello, world”就给抛出难题&lt;br&gt;
    
    </summary>
    
    
      <category term=".NetCore" scheme="https://zhengxin23.github.io/tags/NetCore/"/>
    
  </entry>
  
  <entry>
    <title>.Net性能测试工具BenchmarkDotnet</title>
    <link href="https://zhengxin23.github.io/2019/04/06/20190406-benchmarkDotnet/"/>
    <id>https://zhengxin23.github.io/2019/04/06/20190406-benchmarkDotnet/</id>
    <published>2019-04-06T01:46:26.000Z</published>
    <updated>2019-04-07T01:41:05.499Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>性能基准测试可以帮助程序员对比2个代码段或者方法的性能，这对于代码重写或者重构来说，可以提供一种很好的量化标准。如果没有性能基准测试，很难想象将方法A改为B方法时候，仅凭肉眼如何区分性能的变化。</p></blockquote><h3 id="BenchmarkDotNet"><a href="#BenchmarkDotNet" class="headerlink" title="BenchmarkDotNet"></a>BenchmarkDotNet</h3><p>BenchmarkDotNet是一款强力的.Net性能基准测试库，官网 <a href="https://benchmarkdotnet.org/" target="_blank" rel="noopener">https://benchmarkdotnet.org/</a>。<br>运行时支持<br><a id="more"></a></p><ul><li>NET Framework (4.6+),</li><li>.NET Core (2.0+)</li><li>Mono</li><li>CoreRT。</li></ul><p>BenchmarkDotnet为每个被测试的方法提供了孤立的环境, 使用BenchmarkDotnet, 程序员可以很容易的编写各种性能测试方法，并可以避免许多常见的坑。</p><h3 id="代码基准测试-Code-Benchmarking"><a href="#代码基准测试-Code-Benchmarking" class="headerlink" title="代码基准测试(Code Benchmarking)"></a>代码基准测试(Code Benchmarking)</h3><p>现在我们希望来对比一下Linq to object中First和Single方法的性能</p><blockquote><p>虽然我们知道First的性能肯定比Single高, First方法会在查询到第一个满足条件的对象之后就停止集合遍历，而Single找到第一个满足条件的对象之后，不会停止查找，它会去继续查找集合中的剩余对象，直到遍历整个集合或者在集合中找到第二个匹配条件的对象。 这里我们只是为了演示一下如何进行代码基准测试。</p></blockquote><p>为了使用BenchmarkDotNet来进行代码基准测试，我们首先创建一个空的.Net Core控制台程序。</p><p><img src="https://upload-images.jianshu.io/upload_images/14183497-2b402ba1a47593e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/955/format/webp" alt></p><p>然后我们使用Package Manage Console添加BenchmarkDotNet库</p><p><code>PM&gt; Install-Package BenchmarkDotNet</code></p><p>然后我们修改Program.cs文件, 代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Program</span><br><span class="line">&#123;</span><br><span class="line">    public class SingleVsFirst</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly List&lt;string&gt; _haystack = new List&lt;string&gt;();</span><br><span class="line">        private readonly int _haystackSize = 1000000;</span><br><span class="line">        private readonly string _needle = &quot;needle&quot;;</span><br><span class="line"></span><br><span class="line">        public SingleVsFirst()</span><br><span class="line">        &#123;</span><br><span class="line">            //Add a large amount of items to our list. </span><br><span class="line">            Enumerable.Range(1, _haystackSize).ToList().ForEach(x =&gt; _haystack.Add(x.ToString()));</span><br><span class="line">            //Insert the needle right in the middle. </span><br><span class="line">            _haystack.Insert(_haystackSize / 2, _needle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [Benchmark]</span><br><span class="line">        public string Single() =&gt; _haystack.SingleOrDefault(x =&gt; x == _needle);</span><br><span class="line"></span><br><span class="line">        [Benchmark]</span><br><span class="line">        public string First() =&gt; _haystack.FirstOrDefault(x =&gt; x == _needle);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        var summary = BenchmarkRunner.Run&lt;SingleVsFirst&gt;();</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 代码解释说明 </strong></p><ul><li>以上代码中<code>SingleVsFtirs</code>类是一个测试类。</li><li>测试类中我们生成了一个拥有100万对象的字符串集合。</li><li>我们在集合的中间位置插入了一个测试字符串，字符串的内容是”needle”。</li><li>代码中的<code>Single</code>和<code>First</code>方法，分别调用了Linq to - object的<code>SingleOrDefault</code>和<code>FirstOrDefault</code>方法- 来查询字符串集合中的”needle”字符串。</li><li>在<code>Single</code>和<code>First</code>方法上，我们加入<code>[Benchmark]</code>特性, 拥有该特性的方法会出现在最后的基准检测报告中。</li></ul><blockquote><p>注意：</p><ul><li>测试的方法必须是公开的(public), 如果把public去掉，程序不会产生任何结果</li><li>在运行程序之前，还有一步关键的操作，测试的程序需要使用Release模式编译，并且不能附加任何调试器(Debugger)</li></ul></blockquote><h3 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h3><p>现在我们运行程序，程序产生的最终报告如下</p><table><thead><tr><th>Method</th><th style="text-align:right">Mean</th><th style="text-align:right">Error</th><th style="text-align:right">StdDev</th><th style="text-align:right">Median</th></tr></thead><tbody><tr><td>Single</td><td style="text-align:right">28.12 ms</td><td style="text-align:right">0.9347 ms</td><td style="text-align:right">2.697 ms</td><td style="text-align:right">28.93 ms</td></tr><tr><td>First</td><td style="text-align:right">13.30 ms</td><td style="text-align:right">0.8394 ms</td><td style="text-align:right">2.475 ms</td><td style="text-align:right">14.48 ms</td></tr></tbody></table><h3 id="带测试参数的基准测试-Input-Benchmarking"><a href="#带测试参数的基准测试-Input-Benchmarking" class="headerlink" title="带测试参数的基准测试(Input Benchmarking)"></a>带测试参数的基准测试(Input Benchmarking)</h3><p>BenchmarkDotNet中我们还可以使用<code>[ParamsSource]</code>参数来指定测试的用例范围。<br>在上面的代码中，我们测试了匹配字符串在集合中间位置时，<code>First</code>和<code>Single</code>的效率对比，下面我们修改上面的代码，我们希望分别测试匹配字符串在集合头部，尾部以及中间位置时<code>First</code>和<code>Single</code>的效率对比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line"> </span><br><span class="line">using BenchmarkDotNet.Attributes;</span><br><span class="line">using BenchmarkDotNet.Running;</span><br><span class="line"> </span><br><span class="line">namespace BenchmarkExample</span><br><span class="line">&#123;</span><br><span class="line">    public class SingleVsFirst</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly List&lt;string&gt; _haystack = new List&lt;string&gt;();</span><br><span class="line">        private readonly int _haystackSize = 1000000;</span><br><span class="line"> </span><br><span class="line">        public List&lt;string&gt; _needles =&gt; new List&lt;string&gt; &#123; &quot;StartNeedle&quot;, &quot;MiddleNeedle&quot;, &quot;EndNeedle&quot; &#125;;</span><br><span class="line"> </span><br><span class="line">        public SingleVsFirst()</span><br><span class="line">        &#123;</span><br><span class="line">            //Add a large amount of items to our list. </span><br><span class="line">            Enumerable.Range(1, _haystackSize).ToList().ForEach(x =&gt; _haystack.Add(x.ToString()));</span><br><span class="line"> </span><br><span class="line">            //One at the start. </span><br><span class="line">            _haystack.Insert(0, _needles[0]);</span><br><span class="line">            //One right in the middle. </span><br><span class="line">            _haystack.Insert(_haystackSize / 2, _needles[1]);</span><br><span class="line">            //One at the end. </span><br><span class="line">            _haystack.Insert(_haystack.Count - 1, _needles[2]);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        [ParamsSource(nameof(_needles))]</span><br><span class="line">        public string Needle &#123; get; set; &#125;</span><br><span class="line"> </span><br><span class="line">        [Benchmark]</span><br><span class="line">        public string Single() =&gt; _haystack.SingleOrDefault(x =&gt; x == Needle);</span><br><span class="line"> </span><br><span class="line">        [Benchmark]</span><br><span class="line">        public string First() =&gt; _haystack.FirstOrDefault(x =&gt; x == Needle);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            var summary = BenchmarkRunner.Run&lt;SingleVsFirst&gt;();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 代码解释说明 </strong></p><ul><li>我们创建了测试的用例字符串集合<code>_needles</code></li><li>在构造函数中，我们在字符串集合的头部，中部，尾部分别插入了3个字符串</li><li>我们添加了一个属性<code>Needle</code>, 表示当前测试的用例，在被测试<code>Single</code>和<code>First</code>方法中，我们使用属性<code>Needle</code>来匹配</li><li>在属性Needle上我们加上了参数来源特性<code>[ParamsSource]</code>, 并设置参数来源是<code>_needles</code></li></ul><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>现在我们运行程序，程序产生的最终报告如下</p><table><thead><tr><th>Method</th><th>Needle</th><th style="text-align:right">Mean</th><th style="text-align:right">Error</th><th style="text-align:right">StdDev</th><th style="text-align:right">Median</th></tr></thead><tbody><tr><td>Single</td><td>EndNeedle</td><td style="text-align:right">23,266,757.53 ns</td><td style="text-align:right">432,206.593 ns</td><td style="text-align:right">591,609.263 ns</td><td style="text-align:right">23,236,343.07 ns</td></tr><tr><td>First</td><td>EndNeedle</td><td style="text-align:right">24,984,621.12 ns</td><td style="text-align:right">494,223.345 ns</td><td style="text-align:right">783,890.599 ns</td><td style="text-align:right">24,936,945.21 ns</td></tr><tr><td>Single</td><td>MiddleNeedle</td><td style="text-align:right">21,379,814.14 ns</td><td style="text-align:right">806,253.579 ns</td><td style="text-align:right">2,377,256.870 ns</td><td style="text-align:right">22,436,101.14 ns</td></tr><tr><td>First</td><td>MiddleNeedle</td><td style="text-align:right">11,984,519.09 ns</td><td style="text-align:right">315,184.021 ns</td><td style="text-align:right">924,380.173 ns</td><td style="text-align:right">12,233,700.94 ns</td></tr><tr><td>Single</td><td>StartNeedle</td><td style="text-align:right">23,650,243.23 ns</td><td style="text-align:right">599,968.173 ns</td><td style="text-align:right">714,219.431 ns</td><td style="text-align:right">23,555,402.19 ns</td></tr><tr><td>First</td><td>StartNeedle</td><td style="text-align:right">89.17 ns</td><td style="text-align:right">1.864 ns</td><td style="text-align:right">2.732 ns</td><td style="text-align:right">89.07 ns</td></tr></tbody></table><p>从结果上看</p><ul><li>当匹配字符串在集合头部的时候，<code>First</code>性能比<code>Single</code>高的多</li><li>当匹配字符串在集合中部的时候，<code>First</code>性能是比<code>Single</code>的一倍</li><li>当匹配字符串在集合尾部的时候，<code>First</code>和比<code>Single</code>的性能差不多</li></ul><h3 id="加入内存测试"><a href="#加入内存测试" class="headerlink" title="加入内存测试"></a>加入内存测试</h3><p>在.NET Core中的CSV解析库中，我们使用了以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[MemoryDiagnoser]</span><br><span class="line">    public class CsvBenchmarking</span><br><span class="line">    &#123;</span><br><span class="line">        [Benchmark(Baseline =true)]</span><br><span class="line">        public IEnumerable&lt;Automobile&gt; CSVHelper()</span><br><span class="line">        &#123;</span><br><span class="line">            TextReader reader = new StreamReader(&quot;import.txt&quot;);</span><br><span class="line">            var csvReader = new CsvReader(reader);</span><br><span class="line">            var records = csvReader.GetRecords&lt;Automobile&gt;();</span><br><span class="line">            return records.ToList();</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        [Benchmark]</span><br><span class="line">        public IEnumerable&lt;Automobile&gt; TinyCsvParser()</span><br><span class="line">        &#123;</span><br><span class="line">            CsvParserOptions csvParserOptions = new CsvParserOptions(true, &apos;,&apos;);</span><br><span class="line">            var csvParser = new CsvParser&lt;Automobile&gt;(csvParserOptions, new CsvAutomobileMapping());</span><br><span class="line">     </span><br><span class="line">            var records = csvParser.ReadFromFile(&quot;import.txt&quot;, Encoding.UTF8);</span><br><span class="line">     </span><br><span class="line">            return records.Select(x =&gt; x.Result).ToList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中除了<code>[Benchmark]</code>特性，我们还在测试类<code>CsvBenchmarking</code>上添加了<code>[MemoryDiagnoser]</code>特性，该特性会在测试报告中追加，2个方法执行时的内存使用情况。</p><table><thead><tr><th>Method</th><th style="text-align:right">Mean</th><th style="text-align:right">Scaled</th><th style="text-align:right">Allocated</th></tr></thead><tbody><tr><td>CSVHelper</td><td style="text-align:right">1,404.5 ms</td><td style="text-align:right">1.00</td><td style="text-align:right">244.39 MB</td></tr><tr><td>TinyCsvParser</td><td style="text-align:right">381.6 ms</td><td style="text-align:right">0.27</td><td style="text-align:right">32.53 MB</td></tr></tbody></table><p> 其中Allocated表明了内存占用情况。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> BenchmarkDotNet绝对是.NET开发人员了解代码性能，以及对比代码性能的必备神器。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;性能基准测试可以帮助程序员对比2个代码段或者方法的性能，这对于代码重写或者重构来说，可以提供一种很好的量化标准。如果没有性能基准测试，很难想象将方法A改为B方法时候，仅凭肉眼如何区分性能的变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;BenchmarkDotNet&quot;&gt;&lt;a href=&quot;#BenchmarkDotNet&quot; class=&quot;headerlink&quot; title=&quot;BenchmarkDotNet&quot;&gt;&lt;/a&gt;BenchmarkDotNet&lt;/h3&gt;&lt;p&gt;BenchmarkDotNet是一款强力的.Net性能基准测试库，官网 &lt;a href=&quot;https://benchmarkdotnet.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://benchmarkdotnet.org/&lt;/a&gt;。&lt;br&gt;运行时支持&lt;br&gt;
    
    </summary>
    
    
      <category term=".Net" scheme="https://zhengxin23.github.io/tags/Net/"/>
    
      <category term="性能" scheme="https://zhengxin23.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="BenchmarkDotnet" scheme="https://zhengxin23.github.io/tags/BenchmarkDotnet/"/>
    
  </entry>
  
  <entry>
    <title>ant-design-pro脚手架第一次使用及问题</title>
    <link href="https://zhengxin23.github.io/2019/04/05/20190405-ant-design-pro%E8%84%9A%E6%89%8B%E6%9E%B6%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E5%8F%8A%E9%97%AE%E9%A2%98/"/>
    <id>https://zhengxin23.github.io/2019/04/05/20190405-ant-design-pro脚手架第一次使用及问题/</id>
    <published>2019-04-05T12:27:07.000Z</published>
    <updated>2019-04-11T12:52:58.346Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近计划开发一个中后台平台，学习研究了一段时间 react<br>技术栈，感觉其以组件为核心思想的开发思路，有助于构建可复用的、相对易于维护的系统。由于UI设计方面比较薄弱，想依靠大平台的UI框架。查看了圈，感觉阿里的<br>Ant Design<br>挺符合心水。依靠大平台的设计理念，避免个人用户体验设计理念不足，避免个人开发出来的系统体验东一个想法西一个想法，导致系统体验太不专业。研究了一个<br>ant-design-pro 感觉不错。<br><a id="more"></a><br>开始着手搭建ant-design-pro demo工程，熟悉下。依据官网看似简单的步骤，但在过程中遇到一些莫名的问题，搞了两三天终于运行成功了……</p></blockquote><ol><li><p>参照官网步骤<br> github：<a href="https://github.com/ant-design/ant-design-pro" target="_blank" rel="noopener">https://github.com/ant-design/ant-design-pro</a><br> demo搭建步骤如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ant-design/ant-design-pro.git --depth=1</span><br><span class="line">cd ant-design-pro</span><br><span class="line">npm install</span><br><span class="line">npm start         # visit http://localhost:8000</span><br></pre></td></tr></table></figure></li><li><p>在 <code>npm install</code> 步骤时，一直出现各种依赖包安装失败等等等等等等各种摸不着头脑的问题<br> 如：某个依赖包无法安装、json解析出错等。<br> 如：npm ERR! Error: EPERM: operation not permitted, 使用管理员权限也解决不了<br> 忘记截图保存了，自己脑补下吧~~<br> 如失败提示网上搜索，基本都没有很准确的解决方法。</p></li><li><p>最后通过将 npm 降到版本4后，终于安装部署成功了，汗。<br> 原先安装时，为版本8；中间试过降到版本6也不行。<br> npm降版本命令： <code>npm i npm@4 -g</code></p></li></ol><p>总结这种前端框架，有点不好就是依赖项目太多，每个依赖项目的版本已很多。<br>在版本不匹配时，出现一些莫名其妙的问题，如果很方便的路径进行解决！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近计划开发一个中后台平台，学习研究了一段时间 react&lt;br&gt;技术栈，感觉其以组件为核心思想的开发思路，有助于构建可复用的、相对易于维护的系统。由于UI设计方面比较薄弱，想依靠大平台的UI框架。查看了圈，感觉阿里的&lt;br&gt;Ant Design&lt;br&gt;挺符合心水。依靠大平台的设计理念，避免个人用户体验设计理念不足，避免个人开发出来的系统体验东一个想法西一个想法，导致系统体验太不专业。研究了一个&lt;br&gt;ant-design-pro 感觉不错。&lt;br&gt;
    
    </summary>
    
    
      <category term="react" scheme="https://zhengxin23.github.io/tags/react/"/>
    
      <category term="ant-design" scheme="https://zhengxin23.github.io/tags/ant-design/"/>
    
  </entry>
  
  <entry>
    <title>将已有项目绑定到git上</title>
    <link href="https://zhengxin23.github.io/2019/04/01/2019040101-git-create-repository/"/>
    <id>https://zhengxin23.github.io/2019/04/01/2019040101-git-create-repository/</id>
    <published>2019-04-01T13:54:00.000Z</published>
    <updated>2019-04-02T07:47:42.304Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-创建远程仓库"><a href="#1-创建远程仓库" class="headerlink" title="1. 创建远程仓库"></a><strong>1. 创建远程仓库</strong></h3><ul><li>登录github，在上边创建一个仓库</li><li>复制仓库链接，比如为<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:alex-my/some-project.git </li></ul><a id="more"></a><h3 id="2-初始化本地仓库"><a href="#2-初始化本地仓库" class="headerlink" title="2.初始化本地仓库"></a><strong>2.初始化本地仓库</strong></h3><p>进入本地项目执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 初始化本地仓库</span><br><span class="line">git init</span><br><span class="line">// 添加全部文件</span><br><span class="line">git add .</span><br><span class="line">// 提交到本地仓库</span><br><span class="line">git commit -m “提交说明”</span><br></pre></td></tr></table></figure></p><h3 id="3-本地仓库与远程仓库绑定"><a href="#3-本地仓库与远程仓库绑定" class="headerlink" title="3.本地仓库与远程仓库绑定"></a><strong>3.本地仓库与远程仓库绑定</strong></h3><p>绑定到远程仓库，并提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 绑定，并取一个别名，通常用origin，后面的地址是前边创建的远程仓库地址</span><br><span class="line">git remote add origin git@github.com:alex-my/some-project.git</span><br><span class="line">// 把本地仓库地址提交到远程仓库</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><h3 id="4-修改本地仓库，并提交到远程仓库"><a href="#4-修改本地仓库，并提交到远程仓库" class="headerlink" title="4.修改本地仓库，并提交到远程仓库"></a><strong>4.修改本地仓库，并提交到远程仓库</strong></h3><p>假设修改了README.md文件<br>在根目录或者在文件所在目录执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">// 查看变动</span><br><span class="line">git status</span><br><span class="line">// 提交到本地仓库</span><br><span class="line">git commit -m “modify reade.md”</span><br><span class="line">// 如果是多人合作的项目,请先pull</span><br><span class="line">git pull</span><br><span class="line">// 推送到远程仓库(第一个使用默认,作用和第一个一样)</span><br><span class="line">git push</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><h3 id="5-仓库别名"><a href="#5-仓库别名" class="headerlink" title="5.仓库别名"></a><strong>5.仓库别名</strong></h3><p>如果有多个仓库或者多个分支，在推送或者拉取的时候需要注意<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull 仓库别名 仓库分支</span><br><span class="line">git push 仓库别名 仓库分支</span><br></pre></td></tr></table></figure></p><h3 id="遇到问题-如下图"><a href="#遇到问题-如下图" class="headerlink" title="遇到问题,如下图"></a><strong>遇到问题,如下图</strong></h3><p><img src="https://i.loli.net/2019/04/01/5ca21a42539ac.png" alt><br>解决方法：git push -f origin master</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-创建远程仓库&quot;&gt;&lt;a href=&quot;#1-创建远程仓库&quot; class=&quot;headerlink&quot; title=&quot;1. 创建远程仓库&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 创建远程仓库&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;登录github，在上边创建一个仓库&lt;/li&gt;
&lt;li&gt;复制仓库链接，比如为&lt;a href=&quot;mailto:git@github.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git@github.com&lt;/a&gt;:alex-my/some-project.git &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="git" scheme="https://zhengxin23.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>python函数参数前面单星号（*）和双星号（**）的区别</title>
    <link href="https://zhengxin23.github.io/2019/03/05/20190305-python-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%89%8D%E9%9D%A2%E5%8D%95%E6%98%9F%E5%8F%B7%E5%92%8C%E5%8F%8C%E6%98%9F%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://zhengxin23.github.io/2019/03/05/20190305-python-函数参数前面单星号和双星号的区别/</id>
    <published>2019-03-05T12:30:00.000Z</published>
    <updated>2019-04-11T12:52:48.186Z</updated>
    
    <content type="html"><![CDATA[<p>在python的函数中经常能看到输入的参数前面有一个或者两个星号：例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def foo(param1, *param2):</span><br><span class="line">def bar(param1, **param2):</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>这两种用法其实都是用来将任意个数的参数导入到python函数中。</p><p>单星号（<em>）：</em>agrs<br>将所以参数以元组(tuple)的形式导入：<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def foo(param1, *param2):</span><br><span class="line">    print param1</span><br><span class="line">    print param2</span><br><span class="line">foo(1,2,3,4,5)</span><br></pre></td></tr></table></figure></p><p>1<br>(2, 3, 4, 5)<br>双星号（<strong>）：</strong>kwargs<br>将参数以字典的形式导入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def bar(param1, **param2):</span><br><span class="line">    print param1</span><br><span class="line">    print param2</span><br><span class="line">bar(1,a=2,b=3)</span><br></pre></td></tr></table></figure></p><p>1<br>{‘a’: 2, ‘b’: 3}<br>此外，单星号的另一个用法是解压参数列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def foo(bar, lee):</span><br><span class="line">    print bar, lee</span><br><span class="line">l = [1, 2]</span><br><span class="line">foo(*l)</span><br></pre></td></tr></table></figure></p><p>1 2<br>当然这两个用法可以同时出现在一个函数中：例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def foo(a, b=10, *args, **kwargs):</span><br><span class="line">    print a</span><br><span class="line">    print b</span><br><span class="line">    print args</span><br><span class="line">    print kwargs</span><br><span class="line">foo(1, 2, 3, 4, e=5, f=6, g=7)</span><br></pre></td></tr></table></figure></p><p>1<br>2<br>3 4<br>{‘e’: 5, ‘g’: 7, ‘f’: 6}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在python的函数中经常能看到输入的参数前面有一个或者两个星号：例如&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;def foo(param1, *param2):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def bar(param1, **param2):&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://zhengxin23.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序设置box-shadow阴影在真机上无效</title>
    <link href="https://zhengxin23.github.io/2019/01/06/20190106-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AEbox-shadow%E9%98%B4%E5%BD%B1%E5%9C%A8%E7%9C%9F%E6%9C%BA%E4%B8%8A%E6%97%A0%E6%95%88/"/>
    <id>https://zhengxin23.github.io/2019/01/06/20190106-微信小程序设置box-shadow阴影在真机上无效/</id>
    <published>2019-01-06T12:35:32.000Z</published>
    <updated>2019-04-11T12:52:40.698Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序设置box-shadow阴影无效，如下：</p><p><code>box-shadow: 0rpx 10rpx 50rpx 10rpx #5555551A;</code></p><p>在开发环境上有效，但在真机上无效。<br><a id="more"></a><br>解决办法：<br>使用rgba创建颜色后，在IDE和真机上都有效了。</p><p><code>box-shadow: 0rpx 10rpx 50rpx 10rpx rgba(85, 85, 85, 0.10);</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信小程序设置box-shadow阴影无效，如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;box-shadow: 0rpx 10rpx 50rpx 10rpx #5555551A;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在开发环境上有效，但在真机上无效。&lt;br&gt;
    
    </summary>
    
    
      <category term="微信小程序" scheme="https://zhengxin23.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序post请求服务器端 No HTTP resource was found 问题</title>
    <link href="https://zhengxin23.github.io/2018/11/30/20181130-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Fpost%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AFNo-HTTP-resource-was-found%E9%97%AE%E9%A2%98/"/>
    <id>https://zhengxin23.github.io/2018/11/30/20181130-微信小程序post请求服务器端No-HTTP-resource-was-found问题/</id>
    <published>2018-11-30T02:33:42.000Z</published>
    <updated>2019-04-11T12:52:25.530Z</updated>
    
    <content type="html"><![CDATA[<p>小程序端代码：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">      url: getApp().globalData.webApiUrlRoot + &apos;/api/User/test&apos;,</span><br><span class="line">      method: &apos;POST&apos;,</span><br><span class="line">      header: &#123;</span><br><span class="line">        &apos;content-type&apos;: &apos;application/json&apos; // 默认值</span><br><span class="line">      &#125;,</span><br><span class="line">      data:&#123;</span><br><span class="line">        a:&quot;1&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        console.log(res);</span><br><span class="line">      &#125;,</span><br><span class="line">      complete(res) &#123;</span><br><span class="line">        console.log(res);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>ASP.NET web api :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[HttpPost]</span><br><span class="line">public string test(string a)</span><br><span class="line">&#123;</span><br><span class="line">    return &quot;hello&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请求结果失败，应答内容：<br>“No HTTP resource was found that matches the request URI ‘<a href="http://localhost:57437/api/User/test&#39;.&quot;" target="_blank" rel="noopener">http://localhost:57437/api/User/test&#39;.&quot;</a></p><p>原因为：POST方法只能接收 Content-Type 为 application/x-www-form-urlencoded 和 multipart/form-data 的 POST 数据</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序端代码：&lt;br&gt;
    
    </summary>
    
    
      <category term="微信小程序" scheme="https://zhengxin23.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
</feed>
